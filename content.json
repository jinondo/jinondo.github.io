{"meta":{"title":"Jinondo's Blog","subtitle":"记录一下不白给的博客","description":"这写的是个锤子的博客orz","author":"Jinondo","url":"https://jinondo.github.io","root":"/"},"pages":[{"title":"关于","date":"2021-11-18T11:53:32.704Z","updated":"2021-11-18T11:53:32.704Z","comments":false,"path":"about/index.html","permalink":"https://jinondo.github.io/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-11-18T11:23:45.765Z","updated":"2021-11-18T11:23:45.765Z","comments":false,"path":"books/index.html","permalink":"https://jinondo.github.io/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-11-18T08:06:21.566Z","updated":"2021-11-18T08:06:21.566Z","comments":false,"path":"categories/index.html","permalink":"https://jinondo.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-11-18T11:20:42.398Z","updated":"2021-11-18T11:20:42.398Z","comments":false,"path":"repository/index.html","permalink":"https://jinondo.github.io/repository/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-11-18T11:33:11.288Z","updated":"2021-11-18T11:33:11.288Z","comments":true,"path":"links/index.html","permalink":"https://jinondo.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-18T08:06:21.685Z","updated":"2021-11-18T08:06:21.685Z","comments":false,"path":"tags/index.html","permalink":"https://jinondo.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java并发与Java内存模型","slug":"concurrent-art","date":"2021-11-18T14:34:00.000Z","updated":"2021-11-18T14:34:00.000Z","comments":true,"path":"2021/11/18/concurrent-art/","link":"","permalink":"https://jinondo.github.io/2021/11/18/concurrent-art/","excerpt":"","text":"ps：本文为《Java并发编程的艺术》部分总结 Java 并发机制的底层实现原理Volatile 的应用 定义：Java变成语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排它锁单独获得这个变量。 几个术语： 缓存行（cache line）是CPU缓存中可分配、操作的最小存储单元，就是获取一块内存数据，放入缓存，这块数据成为缓存行。 缓存行填充：当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个高速缓存行到适当的缓存（L1,L2,L3的或所有） 缓存命中“如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取。 写命中：当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到魂村，而不是写回到内存。 写缺失：一个有效的缓存行被写入到不存在的内存区域。 volatile如何保证可见性： 在X86处理器下通过工具获取JIT编译器生成的汇编指令来查看对volatile进行写操作时 ，有volatile修饰的变量进行写操作会多出后面一行 0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp); 关键就在于这个Lock前缀的指令。 Lock前缀的指令在多核处理器下会引发两件事情 1）将当前处理器缓存行的数据写回到系统内存。 Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。但是，在最近的处理器里，LOCK＃信号一般不锁总线，而是锁缓存，毕竟锁总线开销的比较大。 2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效。 处理器如何知道自己缓存值是不是过期了？ 每个处理器通过嗅探在总线上传播的数据来检查自己缓存值是否过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。 volatile的使用优化 这里提到一个JDK7并发包里的一个队列集合类 LinkedTransferQueue 它在使用volatile变量时，用一种追加字节的方式来优化队列出队和入队的性能。 123456789101112131415/** 队列中的头部节点 */private transient f?inal PaddedAtomicReference&lt;QNode&gt; head;/** 队列中的尾部节点 */private transient f?inal PaddedAtomicReference&lt;QNode&gt; tail;static f?inal class PaddedAtomicReference &lt;T&gt; extends AtomicReference T&gt; &#123; // 使用很多4个字节的引用追加到64个字节 Object p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, pa, pb, pc, pd, pe; PaddedAtomicReference(T r) &#123; super(r); &#125; &#125; public class AtomicReference &lt;V&gt; implements java.io.Serializable &#123; private volatile V value; // 省略其他代码｝ 原因： 因为有些处理器的L1、L2或L3缓存的高速缓存行是64个字节宽，不支持部分填充缓存行，这意味着，如果队列的头节点和尾节点都不足64字节的话，处理器会将它们都读到同一个高速缓存行中，在多处理器下每个处理器都会缓存同样的头、尾节点，当一个处理器试图修改头节点时，会将整个缓存行锁定，那么在缓存一致性机制的作用下，会导致其他处理器不能访问自己高速缓存中的尾节点，而队列的入队和出队操作则需要不停修改头节点和尾节点，所以在多处理器的情况下将会严重影响到队列的入队和出队效率。Doug lea使用追加到64字节的方式来填满高速缓冲区的缓存行，避免头节点和尾节点加载到同一个缓存行，使头、尾节点在修改时不会互相锁定。 第一，当然不是在所有情况下volatile变量都要追加到64字节：缓存行非64字节宽的处理器；共享变量不会被频繁写 第二，在JDK8里面已经改了。 第三，这种追加字节的方式在Java7下可能不生效，会淘汰或重新排列无用字段。 synchronized:chart_with_upwards_trend: JDK1,6后优化，增加了偏向锁和轻量级锁。 synchronized在JVM的实现原理： JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。 monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。 Java对象头 synchronized用的锁是存在Java对象头里的，普通对象头是2个字宽，是数组则是3个字宽，其中的一个字宽的内容被称为mark word 其中存储了对象的hashcode，分代年龄和锁信息，重点提及这个锁信息数据。 32位虚拟机和64位虚拟机mark word的储存结构不一样，这里不过多赘述，见原书。 锁升级 Java SE 1.6 为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。 一共四种状态：无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态。 锁可以升级但不能降级，目的是为了提高获得锁和释放锁的效率。 偏向锁HotSpot的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。 当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。 偏向锁的撤销： 偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。 过程： 关闭偏向锁 偏向锁 1.6和1.7默认启用，可以通过命令关闭偏向锁，如果锁经常处于竞争状态的话。 轻量级锁 加锁： 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。 解锁： 轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。 优缺点： 偏向锁解锁解锁不需要额外消耗，如果有竞争则锁撤销有消耗，适用于单线程场景 轻量级锁竞争线程不会阻塞，使用自旋，如果市始终得不到锁，则自旋消耗CPU，适用于追求响应时间。 重量级锁不自旋不消耗CPU，直接阻塞，相应时间慢，适用于追求吞吐量场景。 原子操作的实现原理术语 内存顺序冲突：一般是由假共享引起的，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效（缓存一致性协议针对的是最小存取单元：缓存行），当出现这个内存顺序冲突时，CPU必须清空流水线。 总结来说，就是多核多线程并发场景下，多核要操作的不同变量处于同一缓存行，某cpu更新缓存行中数据，并将其写回缓存，同时其他处理器会使该缓存行失效，如需使用，还需从内存中重新加载。这对效率产生了较大的影响。 处理器实现原子操作： 处理器保证从系统内存中读取或写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他的处理器不能访问这个字节的内存地址。如果是复杂内存操作的原子性，处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。 总线锁定：所谓总线锁就是使用处理器提供的一个LOCK＃信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。 缓存锁定：所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制（对象就是缓存行）来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效 。 不适用缓存行的情况： 操作数据不能缓存在处理器内部，或操作数据跨多个缓存行，这种情况会锁总线。 处理器不支持缓存锁定 Java如何实现原子操作 使用循环CAS实现原子操作 从Java 1.5开始，JDK的并发包里提供了一些类来支持原子操作，如AtomicBoolean（用原子方式更新的boolean值）、AtomicInteger（用原子方式更新的int值）和AtomicLong（用原子方式更新的long值）。这些原子包装类还提供了有用的工具方法，比如以原子的方式将当前值自增1和自减1。 CAS的三大问题： ABA问题，JDK里可以通过AtomicStampedReference 解决，不仅比较预期和更新后的Reference，还比较预期和更新后的Stamp（标志）。 循环时间开销大，这里提处理器的pause指令能提升效率，1是延迟流水线执行命令，2是解决内存顺序冲突。 只能保证一个共享变量的原子操作，JDK中可以通过AtomicReference ，把多个变量放在一个对象里来进行CAS操作。 使用锁机制实现原子操作。（这里提到除了偏向锁，JVM实现锁都使用到循环CAS） Java内存模型Java内存模型基础 在命令式编程中，线程之间的通信机制有两种：共享内存 和 消息传递。 Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。 从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。 线程中的通信可以看成： 1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。2）线程B到主内存中去读取线程A之前已更新过的共享变量。 表面上是线程之间发送该消息，实际通过了主内存这个中间人。 重排序重排序分三种（从Java源码到执行的指令序列也经过这三种 ）： 编译器优化的重排序。 指令级并行的重排序 内存系统的重排序 2和3属于处理器重排序：Java的处理器重排序规则会要求编译器在生成指令序列时插入内存屏障 现代的处理器使用写缓冲区临时保存向内存写入的数据。 但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！ 常见的处理器不允许对存在 数据依赖 的操作做重排序。 **为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。 ** StoreLoad Barriers是一个“全能型”的屏障，它同时具有其他3个屏障的效果。 happens-before简介从JDK 5开始，Java使用新的JSR-133内存模型（除非特别说明，本文针对的都是JSR-133内存模型）。JSR-133使用happens-before的概念来阐述操作之间的内存可见性。在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！ happens-before仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。 重排序 如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。 这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑，我们所说的如果操作没有数据依赖性，编译器和处理器可以进行重排序，是从单线程角度看；从多线程是从整体角度来看了，是另一回事。 as-if-serial as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。 重排序对多线程影响，除了上面所说的数据依赖性以外，还有一个控制依赖性（也是相对于单线程来说的），例如if语句和if下面的语句，在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因）；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。 顺序一致性顺序一致性模型特点： 1）一个线程中的所有操作必须按照程序的顺序来执行。2）（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。 顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照。 当然我认为只是参照而已，JVM没有上面两个特点的保证，这里不展开。 这里提到一点： JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。 原因： 总线的工作机制（提到总线仲裁）可以把所有处理器对内存的访问以串行化的方式来执行。在任意时间点，最多只能有一个处理器可以访问内存。这个特性确保了单个总线事务之中的内存读/写操作具有原子性。 但有一些32位处理器，对64位数据的写操作会拆分成两个32位写操作执行，分配到不同的总线事务中执行，所以没有原子性保证。（也就是可能处理器A写一半，B就看到了写了一半） 注意：在JSR-133之前的旧内存模型中，一个64位long/double型变量的读/写操作可以被拆分为两个32位的读/写操作来执行。从JSR-133内存模型开始（即从JDK5开始），仅仅只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中都必须具有原子性（即任意读操作必须要在单个读事务中执行） volatile的内存语义：**理解volatile特性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。 ** 锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。 锁的语义决定了临界区代码的执行具有原子性。这意味着，即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。 特性如下： 可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。 （这个原子性是因为有锁的语义） volatile写-读的内存语义写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。 读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 总结就是线程间发送消息。 volatile内存语义的实现 为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。 为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。（首先保证正确性，再去追求效率） JSR-133为什么要增强volatile的内存语义 在JSR-133之前的旧Java内存模型中，虽然不允许volatile变量之间重排序，但旧的Java内存模型允许volatile变量与普通变量重排序。 上张图明白，本来是1，2，3, 4，根据volatile规则和程序顺序规则，1的结果对4可见，但： 在旧的内存模型中，volatile的写-读没有锁的释放-获所具有的内存语义 ，所以决定增强，严格限制编译器和处理器对volatile变量与普通变量的重排序 。 可以看出volatile就是一种轻量的锁，在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。 锁的内存语义 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。 当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。 锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。 总结也是线程间的通信。 锁的内存语义的实现这里书中用ReentrantLock为例分析，总结为： 公平锁和非公平锁释放时，最后都要写一个volatile变量state。 公平锁获取时，首先会去读volatile变量。 非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。 对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式。 1）利用volatile变量的写-读所具有的内存语义。 2）利用CAS所附带的volatile读和volatile写的内存语义。 concurrent 包的实现 Java的CAS会使用现代处理器上提供的高效机器级别的原子指令，同时，volatile变量的读/写和CAS可以实现线程之间的通信。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式 ： 首先，声明共享变量为volatile。然后，使用CAS的原子条件更新来实现线程之间的同步（指控制操作顺序的机制）。同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。 AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如所示。 final域的内存语义1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。写final域的重排序规则禁止把final域的写重排序到构造函数之外。 2）初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序 3）对于引用类型：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序 。 这里提到一个final引用不能从构造函数内”溢出”。 比如构造函数： 1234public FinalReferenceEscapeExample () &#123; i = 1; // 1写final域 obj = this; // 2 this引用在此&quot;逸出&quot;&#125; 要保证在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了，2操作是不能出现的。 final域在处理器中的实现简单说就是插入屏障，但也取决于处理器。 **JSR-133为什么要增强final的语义 ** 在旧的Java内存模型中，一个最严重的缺陷就是线程可能看到final域的值会改变。 为了修补这个漏洞，JSR-133专家组增强了final的语义。通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。 happens-beforeJMM把happens-before要求禁止的重排序分为下面两类 会改变程序执行结果的重排序。 不会改变程序执行结果的重排序。 JMM对这两种不同性质的重排序，采取了不同的策略，如下。 对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。 对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）。 JMM向程序员提供的happens-before规则能够满足程序员的需求。JMM的happens-before规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证 。 上面这张图很好地展示了happens-before存在的意义还有和JVM，程序员三者之间的关系关联。:+1: happens-before的定义《JSR-133:Java Memory Model and Thread Specification》对happens-before关系的定义如下 1）如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。2）两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。 上面的1）是JMM对程序员的承诺。 上面的2）是JMM对编译器和处理器重排序的约束原则。 会发现 happens-before关系本质上和as-if-serial语义是一回事。 happens-before规则《JSR-133:Java Memory Model and Thread Specification》定义了如下happens-before规则。 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。 volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。 start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。 join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。 双重检查锁定与延迟初始化在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。 双重检查锁定是常见的延迟初始化技术，但它是一个错误的用法。 书中用了单例模式的代码作为例子讲解，这里不展开。 基于volatile的解决方案123456789101112public class SafeDoubleCheckedLocking &#123; private volatile static Instance instance; public static Instance getInstance() &#123; if (instance == null) &#123; synchronized (SafeDoubleCheckedLocking.class) &#123; if (instance == null) instance = new Instance(); // instance为volatile，现在没问题了 &#125; &#125; return instance; &#125;&#125; 其实就加了个volatile，学过单例的都清楚 这个方案本质上是通过禁止指令（instance = new Instance()涉及的三个指令）之间的重排序，来保证线程安全的延迟初始化。 支持需要JDK5以上版本，因为JSR-133后来增强了volatile的语义。 基于类初始化的解决方案12345678public class InstanceFactory &#123; private static class InstanceHolder &#123; public static Instance instance = new Instance(); &#125; public static Instance getInstance() &#123; return InstanceHolder.instance ; // 这里将导致InstanceHolder类被初始化 &#125;&#125; 原因：类的初始化在JVM中会做同步处理 通过对比基于volatile的双重检查锁定的方案和基于类初始化的方案，我们会发现基于类初始化的方案的实现代码更简洁。 但基于volatile的双重检查锁定的方案有一个额外的优势：除了可以对静态字段实现延迟初始化外，还可以对实例字段实现延迟初始化。 Java内存模型综述这里书中介绍了几种处理器的内存模型，如TSO,PSO,PMO。 而JMM屏蔽了不同处理器内存模型的差异，它在不同的处理器平台之上为Java程序员呈现了一个一致的内存模型。 各种内存模型之间的关系 JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型。 **JSR-133对旧内存模型的修补 ** JSR-133对JDK 5之前的旧内存模型的修补主要有两个。 增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。 增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。在保证final引用不会从构造函数内逸出的情况下，final具有了初始化安全性。","categories":[{"name":"Java","slug":"Java","permalink":"https://jinondo.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jinondo.github.io/tags/Java/"},{"name":"并发编程","slug":"并发编程","permalink":"https://jinondo.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"}]},{"title":"高校健康上报系统后端设计重点","slug":"高校健康上报系统后端设计重点","date":"2021-07-06T07:08:21.000Z","updated":"2021-07-06T07:08:21.000Z","comments":true,"path":"2021/07/06/高校健康上报系统后端设计重点/","link":"","permalink":"https://jinondo.github.io/2021/07/06/%E9%AB%98%E6%A0%A1%E5%81%A5%E5%BA%B7%E4%B8%8A%E6%8A%A5%E7%B3%BB%E7%BB%9F%E5%90%8E%E7%AB%AF%E8%AE%BE%E8%AE%A1%E9%87%8D%E7%82%B9/","excerpt":"","text":"项目结构 Pom文件总父模块pom文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;service&lt;/module&gt; &lt;module&gt;model&lt;/module&gt; &lt;module&gt;common&lt;/module&gt; &lt;module&gt;generator&lt;/module&gt; &lt;/modules&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.university.report&lt;/groupId&gt; &lt;artifactId&gt;health_report&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;health_report&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 引入mybatis-plus入口--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.4.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.11&lt;/version&gt; &lt;/dependency&gt; &lt;!--由于使用到了fastJson，所以引入相关的依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.75&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;easyexcel&lt;/artifactId&gt; &lt;version&gt;2.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 当然最好父模块的pom还是指定依赖的版本比较好 service-user模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;service&lt;/artifactId&gt; &lt;groupId&gt;com.university.report&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;service-user&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-httpclient&lt;/groupId&gt; &lt;artifactId&gt;commons-httpclient&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--RabbitMQ依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.university.report.user.UserServiceApplication&lt;/mainClass&gt;&lt;!-- &lt;layout&gt;zip&lt;/layout&gt;--&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- xml放在java目录下--&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.yml&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.txt&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 对于多模块打包，有 src 文件夹的，就是说该模块下有实际代码的，打包用jar，其余的用pom，例如父模块，里面没有src代码，故打包用pom service-cmn模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;service&lt;/artifactId&gt; &lt;groupId&gt;com.university.report&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;service-cmn&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-core&lt;/artifactId&gt; &lt;version&gt;0.6.1&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;/exclusion&gt; &lt;exclusion&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-extension&lt;/artifactId&gt; &lt;version&gt;0.6.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;mainClass&gt;com.university.report.cmn.CmnServiceApplication&lt;/mainClass&gt; &lt;!-- &lt;layout&gt;zip&lt;/layout&gt;--&gt; &lt;/configuration&gt; &lt;executions&gt; &lt;execution&gt; &lt;goals&gt; &lt;goal&gt;repackage&lt;/goal&gt; &lt;/goals&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;!-- xml放在java目录下--&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.yml&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;include&gt;**/*.txt&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; model模块 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;health_report&lt;/artifactId&gt; &lt;groupId&gt;com.university.report&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;model&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- 引用代码生成器--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.velocity&lt;/groupId&gt; &lt;artifactId&gt;velocity-engine-core&lt;/artifactId&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; common模块 12345678910111213141516171819202122232425262728293031323334&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;health_report&lt;/artifactId&gt; &lt;groupId&gt;com.university.report&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;common-utils&lt;/module&gt; &lt;module&gt;service-utils&lt;/module&gt; &lt;/modules&gt; &lt;dependencies&gt; &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger2 --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/io.springfox/springfox-swagger-ui --&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; service-utils 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;groupId&gt;com.university.report&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;service-utils&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- redis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;groupId&gt;com.university.report&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;common-utils&lt;/artifactId&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;!-- jwt 和 json 包 --&gt; &lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt --&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.university.report&lt;/groupId&gt; &lt;artifactId&gt;model&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 顺便贴一下banner 123456789101112131415 _ _ _ | \\ | | (_) | \\| | _ _ __ __ __ __ _ _ __ __ _ | . ` | | | | &#x27;__| \\ \\ / / / _` | | &#x27;_ \\ / _` || |\\ | | | | | \\ V / | (_| | | | | | | (_| ||_| \\_| |_| |_| \\_/ \\__,_| |_| |_| \\__,_| _____ _ _____ _ / ____| (_) | __ \\ | | | | __ _ __ _ _ _ __ __ _ ___ _ ___ | | | | ___ __ _ __| | | | |_ | | &#x27;__| | | | | | &#x27;_ \\ / _` | / _ \\ | | / __| | | | | / _ \\ / _` | / _` | | |__| | | | | |_| | | | | | | (_| | | __/ | | \\__ \\ | |__| | | __/ | (_| | | (_| | \\_____| |_| \\__,_| |_| |_| \\__, | \\___| |_| |___/ |_____/ \\___| \\__,_| \\__,_| __/ | |___/ 主要技术栈使用MybatisPlus配置123456789101112131415161718192021222324252627282930313233343536package com.university.report.user.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.transaction.annotation.EnableTransactionManagement;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/9 15:48 */@EnableTransactionManagement@MapperScan(&quot;com.university.report.user.mapper&quot;)@Configurationpublic class MybatisPlusConfig &#123; // 乐观锁 @Bean public OptimisticLockerInterceptor OptimisticLockerInnerInterceptor() &#123; return new OptimisticLockerInterceptor(); &#125; // 分页 @Bean public MybatisPlusInterceptor mybatisPlusInterceptor() &#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125;&#125; 1234567891011121314151617181920212223242526272829303132package com.university.report.user.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler;import lombok.extern.slf4j.Slf4j;import org.apache.ibatis.reflection.MetaObject;import org.springframework.stereotype.Component;import java.sql.Timestamp;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/9 15:51 */@Slf4j@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123; @Override public void insertFill(MetaObject metaObject) &#123; log.info(&quot;start insert fill ....&quot;); this.strictInsertFill(metaObject, &quot;createTime&quot;, Timestamp.class, new Timestamp(System.currentTimeMillis())); this.strictInsertFill(metaObject, &quot;updateTime&quot;, Timestamp.class, new Timestamp(System.currentTimeMillis())); this.strictInsertFill(metaObject,&quot;cityTravel&quot;,Integer.class,1); &#125; @Override public void updateFill(MetaObject metaObject) &#123; this.strictUpdateFill(metaObject, &quot;updateTime&quot;, Timestamp.class, new Timestamp(System.currentTimeMillis())); &#125;&#125; 代码生成器 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182package com.university.report;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.annotation.IdType;import com.baomidou.mybatisplus.generator.AutoGenerator;import com.baomidou.mybatisplus.generator.config.DataSourceConfig;import com.baomidou.mybatisplus.generator.config.GlobalConfig;import com.baomidou.mybatisplus.generator.config.PackageConfig;import com.baomidou.mybatisplus.generator.config.StrategyConfig;import com.baomidou.mybatisplus.generator.config.rules.DateType;import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/9 15:22 */public class CodeGenerator &#123; public static void main(String[] args) &#123; // 需要构建一个 代码自动生成器 对象 AutoGenerator mpg = new AutoGenerator(); // 配置策略 // 1、全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(&quot;user.dir&quot;); gc.setOutputDir(projectPath+&quot;/src/main/java&quot;); gc.setAuthor(&quot;Jinondo&quot;); gc.setOpen(false); gc.setFileOverride(false); // 是否覆盖 gc.setServiceName(&quot;%sService&quot;); // 去Service的I前缀 gc.setIdType(IdType.AUTO); gc.setDateType(DateType.SQL_PACK); // gc.setSwagger2(true); // 开启 swagger2 模式 mpg.setGlobalConfig(gc); //2、设置数据源 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(&quot;jdbc:mysql://localhost:3306/health_report?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai&quot;); dsc.setDriverName(&quot;com.mysql.cj.jdbc.Driver&quot;); dsc.setUsername(&quot;root&quot;); dsc.setPassword(&quot;123456&quot;); dsc.setDbType(DbType.MYSQL); mpg.setDataSource(dsc); //3、包的配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(&quot;model&quot;); pc.setParent(&quot;com.university.report&quot;); pc.setEntity(&quot;entity&quot;); pc.setMapper(&quot;mapper&quot;); pc.setService(&quot;service&quot;); pc.setController(&quot;controller&quot;); mpg.setPackageInfo(pc); //4、策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setInclude(&quot;t_dict&quot;); // 设置要映射的表名 strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // 自动lombok； strategy.setLogicDeleteFieldName(&quot;deleted&quot;); strategy.setTablePrefix(&quot;t_&quot;); // 自动填充配置// TableFill createTime = new TableFill(&quot;create_time&quot;, FieldFill.INSERT);// TableFill updateTime = new TableFill(&quot;update_time&quot;, FieldFill.INSERT_UPDATE);// TableFill deleted = new TableFill(&quot;deleted&quot;, FieldFill.INSERT);// TableFill version = new TableFill(&quot;version&quot;, FieldFill.INSERT);// ArrayList&lt;TableFill&gt; tableFills = new ArrayList&lt;&gt;();// tableFills.add(createTime);// tableFills.add(updateTime);// tableFills.add(deleted);// tableFills.add(version);// strategy.setTableFillList(tableFills); // 乐观锁 strategy.setVersionFieldName(&quot;version&quot;); strategy.setRestControllerStyle(true); strategy.setControllerMappingHyphenStyle(true); //驼峰转连字符 mpg.setStrategy(strategy); mpg.execute(); //执行 &#125;&#125; yml配置 1234567891011121314151617181920212223242526272829303132333435363738394041server: port: 8086spring: datasource: username: root password: root url: jdbc:mysql://47.119.146.37:3306/health_report?useUnicode=true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai driver-class-name: com.mysql.cj.jdbc.Driver application: name: service-cmn redis: host: 47.119.146.37 port: 6379 database: 1 connect-timeout: 1800000 lettuce: pool: max-active: 20 max-wait: -1 # 最大阻塞等待时间（负数表示没有限制） max-idle: 5 min-idle: 0 db3: host: 47.119.146.37 port: 6379 database: 3mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: logic-delete-field: deleted logic-delete-value: 1 logic-not-delete-value: 0 table-prefix: t_ mapper-locations: classpath*:/com/university/report/cmn/mapper/xml/*.xml swagger 配置在此项目中，swagger配置我写在 common 模块里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package com.university.report.common.config;import com.google.common.base.Predicates;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.ParameterBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.schema.ModelRef;import springfox.documentation.service.*;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spi.service.contexts.SecurityContext;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;import java.util.ArrayList;import java.util.Arrays;import java.util.List;/** * Swagger2配置信息 */@Configuration@EnableSwagger2public class Swagger2Config &#123; @Bean public Docket webApiConfig()&#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;webApi&quot;) .apiInfo(webApiInfo()) .select() //只显示api路径下的页面 .paths(Predicates.and(PathSelectors.regex(&quot;/api/.*&quot;))) .build() .securityContexts(Arrays.asList(securityContexts())) .securitySchemes(Arrays.asList(securitySchemes())); &#125; @Bean public Docket adminApiConfig()&#123; return new Docket(DocumentationType.SWAGGER_2) .groupName(&quot;adminApi&quot;) .apiInfo(adminApiInfo()) .select() //只显示admin路径下的页面 .paths(Predicates.and(PathSelectors.regex(&quot;/admin/.*&quot;))) .build() .securityContexts(Arrays.asList(securityContexts())) .securitySchemes(Arrays.asList(securitySchemes())); &#125; private ApiInfo webApiInfo()&#123; return new ApiInfoBuilder() .title(&quot;健康上报系统 - API文档&quot;) .description(&quot;本文档描述了网站微服务接口定义&quot;) .description(&quot;注意：时间参数都使用 yyyy-MM-dd 格式&quot;) .version(&quot;1.0&quot;) .contact(new Contact(&quot;Jinondo&quot;, &quot;https://jinondo.github.io/&quot;, &quot;yt18675666273@gmail.com&quot;)) .build(); &#125; private ApiInfo adminApiInfo()&#123; return new ApiInfoBuilder() .title(&quot;后台管理系统-API文档&quot;) .description(&quot;本文档描述了后台管理系统微服务接口定义&quot;) .version(&quot;1.0&quot;) .contact(new Contact(&quot;Jinondo&quot;, &quot;https://jinondo.github.io/&quot;, &quot;yt18675666273@gmail.com&quot;)) .build(); &#125; private SecurityScheme securitySchemes() &#123; return new ApiKey(&quot;Authorization&quot;, &quot;token&quot;, &quot;header&quot;); &#125; private SecurityContext securityContexts() &#123; return SecurityContext.builder() .securityReferences(defaultAuth()) .forPaths(PathSelectors.any()) .build(); &#125; private List&lt;SecurityReference&gt; defaultAuth() &#123; AuthorizationScope authorizationScope = new AuthorizationScope(&quot;xxx&quot;, &quot;描述信息&quot;); AuthorizationScope[] authorizationScopes = new AuthorizationScope[1]; authorizationScopes[0] = authorizationScope; return Arrays.asList(new SecurityReference(&quot;Authorization&quot;, authorizationScopes)); &#125;&#125; 后面三个是配置 SpringSecurity 权限验证 Redis 配置使用在本项目中使用了两个配置，一个是使用注解自动存入redis，一种用redistemplate 单Redis配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133package com.university.report.common.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.JsonTypeInfo;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import com.fasterxml.jackson.databind.jsontype.impl.LaissezFaireSubTypeValidator;import org.apache.commons.pool2.impl.GenericObjectPoolConfig;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.cache.CacheManager;import org.springframework.cache.annotation.Cacheable;import org.springframework.cache.annotation.EnableCaching;import org.springframework.cache.interceptor.KeyGenerator;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Primary;import org.springframework.data.redis.cache.RedisCacheConfiguration;import org.springframework.data.redis.cache.RedisCacheManager;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.connection.RedisStandaloneConfiguration;import org.springframework.data.redis.connection.lettuce.LettuceClientConfiguration;import org.springframework.data.redis.connection.lettuce.LettuceConnectionFactory;import org.springframework.data.redis.connection.lettuce.LettucePoolingClientConfiguration;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.RedisSerializationContext;import org.springframework.data.redis.serializer.RedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import java.lang.reflect.Method;import java.time.Duration;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/12 9:51 */@Configuration@EnableCachingpublic class RedisConfig &#123; /** * 自定义key规则 * @return */ @Bean public KeyGenerator keyGenerator() &#123; return new KeyGenerator() &#123; @Override public Object generate(Object target, Method method, Object... params) &#123; /*这里通过@Cacheable注解，自动生成调用方法和对象的key名字*/// System.out.println(method.getName());// System.out.println(params.toString());// System.out.println(target.toString()); StringBuilder sb = new StringBuilder(); sb.append(target.getClass().getName()); sb.append(method.getName()); for (Object obj : params) &#123; sb.append(obj.toString()); &#125; System.out.println(sb.toString()); return sb.toString(); &#125; &#125;; &#125; /** * 设置RedisTemplate规则 * @param factory * @return */ @Bean public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); redisTemplate.setConnectionFactory(factory); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); // 指定要序列化的域，field,get和set,以及修饰符范围，ANY是都有包括private和public om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); // 指定序列化输入的类型，类必须是非final修饰的，final修饰的类，比如String,Integer等会跑出异常 om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance , ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY); // om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); //序列号key value redisTemplate.setKeySerializer(new StringRedisSerializer()); redisTemplate.setValueSerializer(jackson2JsonRedisSerializer); redisTemplate.setHashKeySerializer(new StringRedisSerializer()); redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer); redisTemplate.afterPropertiesSet(); return redisTemplate; &#125; /** * 设置CacheManager缓存规则 * @param factory * @return */ @Bean public CacheManager cacheManager(RedisConnectionFactory factory) &#123; RedisSerializer&lt;String&gt; redisSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); //解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.activateDefaultTyping(LaissezFaireSubTypeValidator.instance , ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);// om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // 配置序列化（解决乱码的问题）,过期时间600秒 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofSeconds(600)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(factory) .cacheDefaults(config) .build(); return cacheManager; &#125;&#125; 这一部分 yml 配置如下 12345678910111213spring: redis: host: 47.119.146.37 port: 6379 database: 1 connect-timeout: 1800000 lettuce: pool: max-active: 20 max-wait: -1 # 最大阻塞等待时间（负数表示没有限制） max-idle: 5 min-idle: 0 在一个controller里： 1234567891011121314// @CacheEvict(value = &quot;dict&quot;, allEntries=true) 用于导入数据字典时清空缓存@Cacheable(value = &quot;dict&quot;,keyGenerator = &quot;keyGenerator&quot;)@Overridepublic List&lt;Dict&gt; findChildren(Integer id) &#123; QueryWrapper&lt;Dict&gt; wrapper = new QueryWrapper&lt;&gt;(); wrapper.eq(&quot;parent_id&quot;,id); List&lt;Dict&gt; dicts = baseMapper.selectList(wrapper); for (Dict dict : dicts) &#123; boolean hasChildren = this.hasChildren(dict.getId()); dict.setHasChildren(hasChildren); &#125; return dicts;&#125; 多Redis配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114package com.university.report.common.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.connection.RedisStandaloneConfiguration;import org.springframework.data.redis.connection.jedis.JedisClientConfiguration;import org.springframework.data.redis.connection.jedis.JedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.core.StringRedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;import redis.clients.jedis.JedisPoolConfig;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/18 9:46 */@Configurationpublic class RedisMultiConfig &#123; @Value(&quot;$&#123;spring.redis.db2.host:null&#125;&quot;) private String secondHost; @Value(&quot;$&#123;spring.redis.db2.port:0&#125;&quot;) private Integer secondPort; @Value(&quot;$&#123;spring.redis.db2.database:0&#125;&quot;) private Integer secondDatabase; @Value(&quot;$&#123;spring.redis.db3.host:null&#125;&quot;) private String thirdHost; @Value(&quot;$&#123;spring.redis.db3.port:0&#125;&quot;) private Integer thirdPort; @Value(&quot;$&#123;spring.redis.db3.database:0&#125;&quot;) private Integer thirdDatabase; //最大空闲连接数 private static final int MAX_IDLE = 200; // 最小空闲连接数 private static final int MIN_IDLE = 0; //最大连接数 private static final int MAX_TOTAL = 1024; //建立连接最长等待时间 private static final long MAX_WAIT_MILLIS = 10000; /** * 创建redis连接工厂 */ public JedisConnectionFactory createJedisConnectionFactory(int dbIndex, String host, int port) &#123; RedisStandaloneConfiguration redisStandaloneConfiguration = new RedisStandaloneConfiguration(); redisStandaloneConfiguration.setDatabase(dbIndex); redisStandaloneConfiguration.setHostName(host); redisStandaloneConfiguration.setPort(port);// redisStandaloneConfiguration.setPassword(password); // 获得默认的连接池构造器 JedisClientConfiguration.JedisPoolingClientConfigurationBuilder jpcb = (JedisClientConfiguration.JedisPoolingClientConfigurationBuilder)JedisClientConfiguration.builder(); //指定 jedisPoolConfig 来修改默认的连接池构造器 jpcb.poolConfig(poolConfig(MAX_IDLE,MIN_IDLE, MAX_TOTAL, MAX_WAIT_MILLIS, true)); //通过构造器来构造jedis客户端配置 JedisClientConfiguration jedisClientConfiguration = jpcb.build(); JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(redisStandaloneConfiguration, jedisClientConfiguration); jedisConnectionFactory.afterPropertiesSet(); return jedisConnectionFactory; &#125; /** * 连接池配置 * @param maxIdle * @param minIdle * @param maxTotal * @param maxWaitMillis * @param testOnBorrow * @return */ public JedisPoolConfig poolConfig(int maxIdle, int minIdle, int maxTotal, long maxWaitMillis, boolean testOnBorrow) &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxIdle(maxIdle); poolConfig.setMinIdle(minIdle); poolConfig.setMaxTotal(maxTotal); poolConfig.setMaxWaitMillis(maxWaitMillis); poolConfig.setTestOnBorrow(testOnBorrow); return poolConfig; &#125; @Bean(name = &quot;redisTemplate2&quot;) public StringRedisTemplate redisTemplate2() &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory( createJedisConnectionFactory(secondDatabase, secondHost, secondPort)); template.afterPropertiesSet(); return template; &#125; @Bean(name = &quot;redisTemplate3&quot;) public StringRedisTemplate redisTemplate3() &#123; StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory( createJedisConnectionFactory(thirdDatabase, thirdHost, thirdPort)); template.afterPropertiesSet(); return template; &#125;&#125; 如果需要设置序列化： 1234567891011121314151617181920212223242526272829// 自己定义了一个 RedisTemplate// @Bean(name = &quot;redisTemplate3&quot;)@SuppressWarnings(&quot;all&quot;)public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory) &#123; // 我们为了自己开发方便，一般直接使用 &lt;String, Object&gt; RedisTemplate&lt;String, Object&gt; template = new RedisTemplate&lt;String, Object&gt;(); template.setConnectionFactory(factory); // Json序列化配置 Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class); ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jackson2JsonRedisSerializer.setObjectMapper(om); // String 的序列化 StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); // key采用String的序列化方式 template.setKeySerializer(stringRedisSerializer); // hash的key也采用String的序列化方式 template.setHashKeySerializer(stringRedisSerializer); // value序列化方式采用jackson template.setValueSerializer(jackson2JsonRedisSerializer); // hash的value序列化方式采用jackson template.setHashValueSerializer(jackson2JsonRedisSerializer); template.afterPropertiesSet(); return template;&#125; RabbitMQ 配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.university.report.user.config;import com.university.report.common.constant.RabbitMQConst;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.DirectExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/18 14:10 */@Configurationpublic class RabbitMqConfiguration&#123; /** * 声明 Direct 交换机 * @return */ @Bean public DirectExchange directExchange()&#123; return new DirectExchange(RabbitMQConst.DIRECT_EXCHANGE,true,false); &#125; /** * 声明队列 * @return */ @Bean public Queue reportQueue()&#123; return new Queue(RabbitMQConst.REPORT_QUEUE,true); &#125; /** * 完成绑定关系 * @return */ @Bean public Binding smsBinding()&#123; return BindingBuilder.bind(reportQueue()).to(directExchange()).with(RabbitMQConst.REPORT_KEY); &#125;&#125; yml配置 1234567891011121314spring: rabbitmq: host: 47.119.146.37 port: 5672 username: admin password: admin # addresses: 47.119.146.37 listener: direct: acknowledge-mode: manual #手动签收 template: receive-timeout: 30000 reply-timeout: 30000 virtual-host: / 生产者： 1234567891011121314@Overridepublic void reportMQ(ReportInfo reportInfo) &#123; try &#123; Message msg= MessageBuilder.withBody(objectMapper.writeValueAsBytes(reportInfo)).setDeliveryMode(MessageDeliveryMode.NON_PERSISTENT) .build(); // 发送消息 rabbitTemplate.convertAndSend(RabbitMQConst.DIRECT_EXCHANGE,RabbitMQConst.REPORT_KEY,msg); log.info(&quot;&gt;&gt; 健康上报消息发送成功 &lt;&lt;&quot;); &#125; catch (JsonProcessingException e) &#123; log.info(&quot;&gt;&gt; 健康上报消息发送失败 &lt;&lt;&quot;); e.printStackTrace(); &#125;&#125; 消费者： 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.university.report.user.consumer;import com.fasterxml.jackson.databind.ObjectMapper;import com.university.report.common.constant.RabbitMQConst;import com.university.report.model.entity.ReportInfo;import com.university.report.model.entity.UserInfo;import com.university.report.model.exception.UserNotFoundException;import com.university.report.user.mapper.ReportInfoMapper;import com.university.report.user.mapper.UserInfoMapper;import com.university.report.user.service.ReportInfoService;import lombok.extern.slf4j.Slf4j;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.messaging.handler.annotation.Payload;import org.springframework.stereotype.Component;import java.sql.Timestamp;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/18 14:41 */@Component@Slf4jpublic class ReportInfoConsumer &#123; @Autowired ObjectMapper objectMapper; @Autowired ReportInfoService reportInfoService; @RabbitListener(queues = &#123;RabbitMQConst.REPORT_QUEUE&#125;) public void receiveReport(@Payload byte[] message)&#123; try &#123; ReportInfo reportInfo = objectMapper.readValue(message,ReportInfo.class); log.info(&quot;&gt;&gt; 健康上报消息成功接受 &lt;&lt;&quot;); ReportInfoService.ReportStatus status = reportInfoService.report(reportInfo); log.info(status.getMessage()); &#125; catch (Exception e)&#123; log.info(&quot;=== 监听消费健康上报消息 发生异常 ===&quot;); e.printStackTrace(); &#125; &#125;&#125; WebMagic爬虫 主要涉及三个类 爬虫启动类 123456789101112131415161718192021222324252627282930313233343536package com.university.report.cmn.handler;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import us.codecraft.webmagic.Spider;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/20 21:41 */@Component@Slf4jpublic class ImportantRegionTasks &#123; @Autowired RedisTemplate redisTemplate3; @Scheduled(cron = &quot;01 00 00 * * *&quot;) public void updateImportantRegion()&#123; log.info(&quot;======= start update ImportantRegion =======&quot;); // 爬取开始 Spider .create(new ImpRegionPageProcessor()) .addPipeline(new ImpRegionPipeline(redisTemplate3)) // 爬取的第一个页面 .addUrl(&quot;http://m.bendibao.com/news/gelizhengce/fengxianmingdan.php&quot;) // 启用的线程数 .thread(2).run(); &#125;&#125; 爬虫过程类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.university.report.cmn.handler;import lombok.extern.slf4j.Slf4j;import us.codecraft.webmagic.Page;import us.codecraft.webmagic.Site;import us.codecraft.webmagic.processor.PageProcessor;import us.codecraft.webmagic.selector.Html;import java.util.ArrayList;import java.util.List;/** * 用于爬取高风险地区的 PageProcessor * @ClassName web-magic-test * @Author Jinondo * @Date 2021/6/20 20:09 */@Slf4jpublic class ImpRegionPageProcessor implements PageProcessor &#123; // 部分一：抓取网站的相关配置，包括编码、抓取间隔、重试次数等 private Site site = Site .me() .setTimeOut(10000) .setRetryTimes(3) .setSleepTime(1000) .setCharset(&quot;UTF-8&quot;) .addHeader(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36&quot;); ; // 獲得站點 @Override public Site getSite() &#123; return site; &#125; //爬取過程 @Override public void process(Page page) &#123; //获取当前页的所有风险地区 List&lt;String&gt; heightList = page.getHtml().xpath(&quot;//div[@class=&#x27;height&#x27;]/div/ul/li&quot;).all(); List&lt;String&gt; middleList = page.getHtml().xpath(&quot;//div[@class=&#x27;middle&#x27;]/div/ul/li&quot;).all(); //要保存风险地区的集合 List&lt;String&gt; heights = new ArrayList&lt;&gt;(); List&lt;String&gt; middles = new ArrayList&lt;&gt;(); //遍历风险地区 for (String item : heightList) &#123; Html tmp = Html.create(item); String region = tmp.xpath(&quot;//span/text()&quot;).toString(); heights.add(region); &#125; for (String item : middleList) &#123; Html tmp = Html.create(item); String region = tmp.xpath(&quot;//span/text()&quot;).toString(); middles.add(region); &#125; log.info(&quot;高风险地区-&gt;&quot; + heights.toString()); log.info(&quot;中风险地区-&gt;&quot; + middles.toString()); List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;List&lt;String&gt;&gt;()&#123;&#123; add(heights); add(middles); &#125;&#125;; page.putField(&quot;importantRegions&quot;, res); &#125;&#125; 爬虫结果处理类 123456789101112131415161718192021222324252627282930313233343536373839package com.university.report.cmn.handler;import com.alibaba.fastjson.JSON;import org.springframework.data.redis.core.RedisTemplate;import us.codecraft.webmagic.ResultItems;import us.codecraft.webmagic.Task;import us.codecraft.webmagic.pipeline.Pipeline;import java.sql.Date;import java.text.SimpleDateFormat;import java.util.List;import java.util.concurrent.TimeUnit;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/20 21:49 */public class ImpRegionPipeline implements Pipeline &#123; private final RedisTemplate redisTemplate3; public ImpRegionPipeline(RedisTemplate redisTemplate3) &#123; this.redisTemplate3 = redisTemplate3; &#125; @Override public void process(ResultItems resultItems, Task task) &#123; List&lt;List&lt;String&gt;&gt; importantRegions = resultItems.get(&quot;importantRegions&quot;); saveToRedis(importantRegions); &#125; public void saveToRedis(List&lt;List&lt;String&gt;&gt; importantRegions)&#123; String format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;).format(new Date(System.currentTimeMillis())); String value = JSON.toJSONString(importantRegions); redisTemplate3.opsForValue().set(&quot;ImportantRegion:&quot;+format,value,1, TimeUnit.DAYS); &#125;&#125; SpringSecurity 配置主配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.university.report.user.config;import com.university.report.common.utils.MD5Util;import com.university.report.model.entity.Permission;import com.university.report.user.filter.JWTLoginFilter;import com.university.report.user.filter.JWTValidationFilter;import com.university.report.user.filter.JwtAuthenticationTokenFilter;import com.university.report.user.handler.MyLogoutHandler;import com.university.report.user.handler.MyLogoutSuccessHandler;import com.university.report.user.mapper.PermissionMapper;import com.university.report.user.service.impl.MemberUserDetailsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.http.HttpMethod;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.crypto.password.NoOpPasswordEncoder;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import org.springframework.stereotype.Component;import java.util.List;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/16 18:04 */@Component@EnableWebSecuritypublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123; @Autowired private RedisTemplate redisTemplate2; @Autowired private MemberUserDetailsService memberUserDetailsService; @Autowired private PermissionMapper permissionMapper; /** * 注销操作处理器 */ @Autowired private MyLogoutHandler myLogoutHandler; /** * 注销成功处理器 */ @Autowired private MyLogoutSuccessHandler myLogoutSuccessHandler; @Autowired JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;// @Autowired// JWTValidationFilter jwtValidationFilter; /** * 添加授权账户 * * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception &#123; auth.userDetailsService(memberUserDetailsService).passwordEncoder(new PasswordEncoder() &#123; @Override public String encode(CharSequence rawPassword) &#123; return MD5Util.encode((String) rawPassword); &#125; /** * rawPassword 用户输入的密码 * encodedPassword 数据库DB的密码 * @param rawPassword * @param encodedPassword * @return */ @Override public boolean matches(CharSequence rawPassword, String encodedPassword) &#123; String rawPass = MD5Util.encode((String) rawPassword); boolean result = rawPass.equals(encodedPassword); return result; &#125; &#125;); &#125; @Override protected void configure(HttpSecurity http) throws Exception &#123; http.addFilterAt(new JWTLoginFilter(authenticationManager(),redisTemplate2),UsernamePasswordAuthenticationFilter.class)// .addFilterAfter(jwtAuthenticationTokenFilter, JWTLoginFilter.class);// .addFilterAfter(jwtValidationFilter,JWTLoginFilter.class); .addFilterAfter(new JWTValidationFilter(authenticationManager(),redisTemplate2),JWTLoginFilter.class); List&lt;Permission&gt; allPermission = permissionMapper.selectList(null); ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry expressionInterceptUrlRegistry = http.authorizeRequests(); allPermission.forEach((permission) -&gt; &#123; expressionInterceptUrlRegistry.antMatchers(permission.getUrl()). hasAnyAuthority(permission.getPermTag()); &#125;); expressionInterceptUrlRegistry .antMatchers(&quot;/auth/login&quot;).permitAll() .antMatchers(&quot;/login/**&quot;).permitAll() .antMatchers(&quot;/api/exportUnReported&quot;).permitAll() .antMatchers(&quot;/api/exportUser&quot;).permitAll() .antMatchers(&quot;/**&quot;).fullyAuthenticated() .and() .logout().permitAll() .addLogoutHandler(myLogoutHandler) .logoutSuccessHandler(myLogoutSuccessHandler) //登出之后删除 cookie .deleteCookies(&quot;JSESSIONID&quot;) .and() .csrf().disable() // 剔除 session .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); &#125; @Override public void configure(WebSecurity web) throws Exception &#123; //放行swagger web.ignoring().antMatchers(HttpMethod.GET, &quot;/v2/api-docs&quot;, &quot;/swagger-resources&quot;, &quot;/swagger-resources/**&quot;, &quot;/configuration/ui&quot;, &quot;/configuration/security&quot;, &quot;/swagger-ui.html/**&quot;, &quot;/webjars/**&quot;); &#125;&#125; MemberUserDetailsService12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.university.report.user.service.impl;import com.university.report.model.entity.Permission;import com.university.report.model.entity.UserAccount;import com.university.report.user.mapper.UserAccountMapper;import lombok.SneakyThrows;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.core.AuthenticationException;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.stereotype.Component;import java.util.ArrayList;import java.util.List;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/16 18:00 */@Component@Slf4jpublic class MemberUserDetailsService implements UserDetailsService &#123; @Autowired UserAccountMapper userAccountMapper; @SneakyThrows @Override public UserDetails loadUserByUsername(String username) throws AuthenticationException &#123; // 1.根据该用户名称查询在数据库中是否存在 UserAccount userAccount = userAccountMapper.selectByUsername(username); if (userAccount == null) &#123; return null; &#125; // 2.查询对应的用户权限 List&lt;Permission&gt; listPermission = userAccountMapper.findPermissionByUsername(username); List&lt;GrantedAuthority&gt; authorities = new ArrayList&lt;GrantedAuthority&gt;(); listPermission.forEach(user -&gt; &#123; authorities.add(new SimpleGrantedAuthority(user.getPermTag())); &#125;); log.info(&quot;&gt;&gt;&gt;authorities:&#123;&#125;&lt;&lt;&lt;&quot;, authorities); // 3.将该权限添加到security userAccount.setAuthorities(authorities); return userAccount; &#125;&#125; 三个过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.university.report.user.filter;import com.university.report.common.utils.JwtUtil;import com.university.report.user.service.impl.MemberUserDetailsService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;import org.springframework.stereotype.Component;import org.springframework.util.StringUtils;import org.springframework.web.filter.OncePerRequestFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;/** * @author KiraYous * @version V1.0 * @Package com.university.report.user.filter * @date 2021/6/19 3:07 */@Component(&quot;jwtAuthenticationTokenFilter&quot;)public class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123; @Autowired private MemberUserDetailsService memberUserDetailsService; private final String HEADER = &quot;token&quot;; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; //判断token是否合法,如果token是合法的,那就意味着已经进行过登录了 //从请求头中获取token String token = request.getHeader(HEADER); System.out.println(&quot;headerToken = &quot; + token); System.out.println(&quot;request getMethod = &quot; + request.getMethod()); //判断token是否为空 if (!StringUtils.isEmpty(token)) &#123; //postMan测试时，自动加入的前缀要去掉。// String token = headerToken.replace(&quot;Bearer&quot;, &quot;&quot;).trim(); System.out.println(&quot;token = &quot; + token); //判断令牌是否过期，默认是一周 //比较好的解决方案是： //登录成功获得token后，将token存储到数据库（redis） //将数据库版本的token设置过期时间为15~30分钟 //如果数据库中的token版本过期，重新刷新获取新的token //注意：刷新获得新token是在token过期时间内有效。 //如果token本身的过期（1周），强制登录，生成新token。 //假设token是无效的 boolean check = false; try &#123; //验证token是否过期 check = JwtUtil.isTokenExpired(token); &#125; catch (Exception e) &#123; //过期则抛出异常 new Throwable(&quot;令牌已过期，请重新登录。&quot;+e.getMessage()); &#125; //如果没有过期,则要验证token的合法性了 if(!check)&#123; //通过令牌获取用户名称 String username = JwtUtil.getUsername(token); System.out.println(&quot;username = &quot; + username); //拿到用户名之后,重新通过userService的loadUserByUsername方法重新得到一个用户 //放到securityContext的上下文中就行了 //判断用户不为空，且SecurityContextHolder授权信息还是空的 if(username != null &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == null)&#123; UserDetails userDetails = memberUserDetailsService.loadUserByUsername(username); //验证令牌有效性 boolean validata = false; try &#123; validata = JwtUtil.validateToken(token,userDetails); &#125; catch (Exception e) &#123; new Throwable(&quot;验证token无效:&quot;+e.getMessage()); &#125; if (validata) &#123; // 将用户信息存入 authentication，方便后续校验 UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken( userDetails, null, userDetails.getAuthorities() ); // authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request)); // 将 authentication 存入 ThreadLocal，方便后续获取用户信息 SecurityContextHolder.getContext().setAuthentication(authentication); &#125; &#125; &#125; &#125; chain.doFilter(request, response); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132package com.university.report.user.filter;import com.fasterxml.jackson.databind.ObjectMapper;import com.university.report.common.result.Result;import com.university.report.common.result.ResultCodeEnum;import com.university.report.common.result.ResultCodeEnum;import com.university.report.common.utils.JSONAuthentication;import com.university.report.common.utils.JwtUtil;import com.university.report.model.entity.UserAccount;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.authentication.*;import org.springframework.security.core.Authentication;import org.springframework.security.core.AuthenticationException;import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.ArrayList;import java.util.concurrent.TimeUnit;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/16 18:21 */public class JWTLoginFilter extends UsernamePasswordAuthenticationFilter &#123; /** * 获取redisTemplate */ RedisTemplate redisTemplate2; /** * 获取授权管理 */ private AuthenticationManager authenticationManager; public JWTLoginFilter(AuthenticationManager authenticationManager,RedisTemplate redisTemplate2) &#123; this.redisTemplate2 = redisTemplate2; this.authenticationManager = authenticationManager; /** * 后端登陆接口 对登陆路径放行 */ super.setFilterProcessesUrl(&quot;/auth/login&quot;); &#125; @Override public Authentication attemptAuthentication(HttpServletRequest req, HttpServletResponse res) &#123; try &#123; UserAccount user = new ObjectMapper() .readValue(req.getInputStream(), UserAccount.class); return authenticationManager.authenticate( new UsernamePasswordAuthenticationToken( user.getUsername(), user.getPassword(), new ArrayList&lt;&gt;()) ); &#125; catch (IOException e) &#123; logger.error(e.getMessage()); return null; &#125; &#125; @Override /** * 用户登陆成功之后验证 */ protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException &#123; UserAccount userEntity = (UserAccount) authResult.getPrincipal(); String jwtToken = JwtUtil.generateJsonWebToken(userEntity); String currentTime = String.valueOf(System.currentTimeMillis()); String accesskey = JwtUtil.ACCESS_TOKEN + &quot;:&quot; + jwtToken; //往拼接存到redis中的Key存value值 redisTemplate2.opsForValue().set(accesskey,currentTime); //设置redis key的过期时间 2天 redisTemplate2.expire(accesskey,2, TimeUnit.DAYS); response.addHeader(&quot;token&quot;, jwtToken); Result result = Result.ok(&quot;登录成功&quot;); JSONAuthentication.writeJSON(request,response,result); &#125;/* SpringSecurity的异常处理是在过滤器中进行的，我们在 AbastrctAuthenticationProcessingFilter 中找到了对 Authentication 的处理： 在 doFilter() 中，捕获 AuthenticationException 异常，并交给 unsuccessfulAuthentication() 处理。 处理的大致流程为： –&gt; AbstractAuthenticationProcessingFilter.doFilter() –&gt; AbstractAuthenticationProcessingFilter.unsuccessfulAuthentication() –&gt; SimpleUrlAuthenticationFailureHandler.onAuthenticationFailure() –&gt; SimpleUrlAuthenticationFailureHandler.saveException() */ @Override protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException e) throws IOException, ServletException &#123; Result result; if (e instanceof AccountExpiredException) &#123; //账号过期 result = Result.fail(ResultCodeEnum.USER_ACCOUNT_EXPIRED); &#125; else if (e instanceof BadCredentialsException) &#123; //密码错误 result = Result.fail(ResultCodeEnum.USER_CREDENTIALS_ERROR); &#125; else if (e instanceof CredentialsExpiredException) &#123; //密码过期 result = Result.fail(ResultCodeEnum.USER_CREDENTIALS_EXPIRED); &#125; else if (e instanceof DisabledException) &#123; //账号不可用 result = Result.fail(ResultCodeEnum.USER_ACCOUNT_DISABLE); &#125; else if (e instanceof LockedException) &#123; //账号锁定 result = Result.fail(ResultCodeEnum.USER_ACCOUNT_LOCKED); &#125; else if (e instanceof InternalAuthenticationServiceException) &#123; //用户不存在 result = Result.fail(ResultCodeEnum.USER_ACCOUNT_NOT_EXIST); &#125;else&#123; //其他错误 result = Result.fail(ResultCodeEnum.FAIL); &#125; //输出 JSONAuthentication.writeJSON(request, response, result); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.university.report.user.filter;import com.university.report.common.utils.JwtUtil;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.util.List;import java.util.concurrent.TimeUnit;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/16 18:23 */public class JWTValidationFilter extends BasicAuthenticationFilter &#123; /** * 获取redisTemplate */ RedisTemplate redisTemplate2; public JWTValidationFilter(AuthenticationManager authenticationManager,RedisTemplate redisTemplate2) &#123; super(authenticationManager); this.redisTemplate2 = redisTemplate2; &#125; /** * 过滤请求验证 * * @param request * @param response * @param chain * @throws IOException * @throws ServletException */ @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException &#123; String token = request.getHeader(&quot;token&quot;); SecurityContextHolder.getContext().setAuthentication(setAuthentication(token)); super.doFilterInternal(request, response, chain); &#125; /** * 验证token 并且验证权限 * @param token * @return */ private UsernamePasswordAuthenticationToken setAuthentication(String token) &#123; String username = JwtUtil.getUsername(token); if (username == null) &#123; return null; &#125; //拼接存到redis中的Key中 String accessKey=JwtUtil.ACCESS_TOKEN+&quot;:&quot;+token; //验证redis中的token得值是否存在 if(!redisTemplate2.hasKey(accessKey))&#123; //登录失败 System.out.println(&quot;不会是这里的吧？&quot;); return null; &#125; String currentTime = String.valueOf(System.currentTimeMillis()); //往拼接存到redis中的Key存value值 redisTemplate2.opsForValue().set(accessKey,currentTime); //设置redis key的过期时间 2 天 redisTemplate2.expire(accessKey,2, TimeUnit.DAYS); List&lt;SimpleGrantedAuthority&gt; userRoleList = JwtUtil.getUserAuthorities(token); System.out.println(userRoleList); return new UsernamePasswordAuthenticationToken(username, null, userRoleList); &#125;&#125; 登出操作123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.university.report.user.handler;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/20 9:17 */import com.university.report.common.utils.JSONAuthentication;import com.university.report.common.utils.JwtUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.security.core.Authentication;import org.springframework.security.core.context.SecurityContextHolder;import org.springframework.security.web.authentication.logout.LogoutHandler;import org.springframework.stereotype.Component;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 退出Handler */@Component(&quot;myLogoutHandler&quot;)@Slf4jpublic class MyLogoutHandler extends JSONAuthentication implements LogoutHandler &#123; @Autowired RedisTemplate redisTemplate2; @Override public void logout(HttpServletRequest request, HttpServletResponse response, Authentication authentication) &#123; String jwtToken = request.getHeader(&quot;token&quot;); log.info(&quot;logout header Token = &quot; + jwtToken); log.info(&quot;logout request getMethod = &quot; + request.getMethod()); // if (jwtToken!=null &amp;&amp; !&quot;&quot;.equals(jwtToken)) &#123; String accesskey = JwtUtil.ACCESS_TOKEN + &quot;:&quot; + jwtToken; redisTemplate2.delete(accesskey); log.info(&quot;authentication = &quot; + authentication); SecurityContextHolder.clearContext(); &#125; &#125;&#125; 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236package com.university.report.common.utils;import com.alibaba.fastjson.JSONArray;import com.university.report.model.entity.UserAccount;import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import java.util.Date;import java.util.HashMap;import java.util.List;import java.util.Map;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/16 18:14 */public class JwtUtil &#123; public static final String TOKEN_HEADER = &quot;token&quot;; public static final String TOKEN_PREFIX = &quot;Bearer &quot;; private static final String SUBJECT = &quot;jinondo&quot;; /** * 设置过期时间为 2天 */ private static final long EXPIRATION_TIME = 1000 * 24 * 60 * 60 * 2; private static final String APPSECRET_KEY = &quot;jinondo_secret&quot;; private static final String ROLE_CLAIMS = &quot;roles&quot;; public static final String AUTHORITY_CLAIMS = &quot;authorities&quot;; public static final String ACCESS_TOKEN = &quot;ACCESS_TOKEN&quot;; public static String generateJsonWebToken(UserAccount user) &#123; String token = Jwts .builder() .setSubject(SUBJECT) .claim(ROLE_CLAIMS,user.getRoleName()) .claim(AUTHORITY_CLAIMS, user.getAuthorities()) .claim(&quot;username&quot;, user.getUsername()) .claim(&quot;userId&quot;, user.getUserId()) .setIssuedAt(new Date()) .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME)) .signWith(SignatureAlgorithm.HS256, APPSECRET_KEY).compact(); return token; &#125; /** * 生成token * * @param username * @param role * @return */ public static String createToken(String username, String role) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(ROLE_CLAIMS, role); String token = Jwts .builder() .setSubject(username) .setClaims(map) .claim(&quot;username&quot;, username) .setIssuedAt(new Date()) // 不设置过期时间，通过redis去判断// .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME)) .signWith(SignatureAlgorithm.HS256, APPSECRET_KEY).compact(); return token; &#125; /* 这个是校验?*/ public static Claims checkJWT(String token) &#123; try &#123; final Claims claims = Jwts.parser().setSigningKey(APPSECRET_KEY).parseClaimsJws(token).getBody(); return claims; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 刷新令牌 * * @param token 原令牌 * @return 新令牌 */ public static String refreshToken(String token) &#123; String refreshedToken; try &#123; Claims claims = getClaimsFromToken(token); claims.put(Claims.ISSUED_AT, new Date()); refreshedToken = generateToken(claims);//通过claims来创建 &#125; catch (Exception e) &#123; refreshedToken = null; &#125; return refreshedToken; &#125; /** * 从数据声明生成令牌 * * @param claims 数据声明 * @return 令牌 */ private static String generateToken(Map&lt;String, Object&gt; claims) &#123; Date expirationDate = new Date(System.currentTimeMillis()+ EXPIRATION_TIME); return Jwts.builder().setClaims(claims).setExpiration(expirationDate).signWith(SignatureAlgorithm.HS512, APPSECRET_KEY).compact(); &#125; /** * 验证令牌 * * @param token 令牌 * @param userDetails 用户 * @return 是否有效 */ public static Boolean validateToken(String token, UserDetails userDetails) throws Exception &#123; UserAccount user=null; if (userDetails instanceof UserAccount) &#123; user = (UserAccount) userDetails; &#125;else throw new Exception(&quot;出错啦！！！&quot;); String username = getUsernameFromToken(token); return (username.equals(user.getUsername()) &amp;&amp; !isTokenExpired(token)); &#125; /** * 获取用户名 * * @param token * @return */ public static String getUsername(String token) &#123; if (token==null)&#123; return null; &#125; Claims claims = Jwts.parser().setSigningKey(APPSECRET_KEY).parseClaimsJws(token).getBody(); return claims.get(&quot;username&quot;).toString(); &#125; /** * 获取用户角色 * * @param token * @return */ public static List&lt;SimpleGrantedAuthority&gt; getUserAuthorities(String token) &#123; Claims claims = Jwts.parser().setSigningKey(APPSECRET_KEY).parseClaimsJws(token).getBody(); List roles = (List) claims.get(AUTHORITY_CLAIMS); String json = JSONArray.toJSONString(roles); List&lt;SimpleGrantedAuthority&gt; grantedAuthorityList = JSONArray.parseArray(json, SimpleGrantedAuthority.class); return grantedAuthorityList; &#125; /** * 从令牌中获取用户名 * * @param token 令牌 * @return 用户名 */ public static String getUsernameFromToken(String token) &#123; String username = null; try &#123; Claims claims = getClaimsFromToken(token); System.out.println(&quot;claims = &quot; + claims.toString());// username = claims.getSubject(); username=claims.get(&quot;username&quot;).toString(); &#125; catch (Exception e) &#123; System.out.println(&quot;e = &quot; + e.getMessage()); &#125; return username; &#125; /** * 是否过期 * * @param token * @return */ public static boolean isExpiration(String token) &#123; Claims claims = Jwts.parser().setSigningKey(APPSECRET_KEY).parseClaimsJws(token).getBody(); return claims.getExpiration().before(new Date()); &#125; /** * 判断令牌是否过期，通过抛异常的方式 * * @param token 令牌 * @return 是否过期 */ public static Boolean isTokenExpired(String token) throws Exception&#123; try &#123; Claims claims = getClaimsFromToken(token); Date expiration = claims.getExpiration(); return expiration.before(new Date()); &#125; catch (Exception e) &#123; new Throwable(e); &#125; return true; &#125; /** * 从令牌中获取数据声明,以抛异常的方式 * * @param token 令牌 * @return 数据声明 */ private static Claims getClaimsFromToken(String token) throws Exception &#123; Claims claims = null; try &#123; claims = Jwts.parser().setSigningKey(APPSECRET_KEY).parseClaimsJws(token).getBody(); &#125; catch (Exception e) &#123; new Throwable(e); &#125; return claims; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435package com.university.report.common.utils;import java.security.MessageDigest;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/16 18:06 */public class MD5Util &#123; private static final String SALT = &quot;jinondo&quot;; public static String encode(String password) &#123; password = password + SALT; MessageDigest md5 = null; try &#123; md5 = MessageDigest.getInstance(&quot;MD5&quot;); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; char[] charArray = password.toCharArray(); byte[] byteArray = new byte[charArray.length]; for (int i = 0; i &lt; charArray.length; i++) &#123; byteArray[i] = (byte) charArray[i]; &#125; byte[] md5Bytes = md5.digest(byteArray); StringBuffer hexValue = new StringBuffer(); for (int i = 0; i &lt; md5Bytes.length; i++) &#123; int val = ((int) md5Bytes[i]) &amp; 0xff; if (val &lt; 16) &#123; hexValue.append(&quot;0&quot;); &#125; hexValue.append(Integer.toHexString(val)); &#125; return hexValue.toString(); &#125;&#125; easyExcel 使用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.university.report.common.utils;import com.alibaba.excel.EasyExcel;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.OutputStream;import java.net.URLEncoder;import java.util.List;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/13 10:23 */public class ExcelUtils &#123; public static void exportExcel(HttpServletResponse response, List data, Class classOb,String fileName, String sheetName) throws IOException &#123; OutputStream xlsOutputStream = getXlsxOutputStream(response,fileName); EasyExcel.write(xlsOutputStream, classOb) .sheet(sheetName) .registerWriteHandler(new TitleSheetWriteHandler()) .doWrite(data); &#125; public static void exportExcel(HttpServletResponse response, List data, Class classOb,String fileName) throws IOException &#123; OutputStream xlsxOutputStream = getXlsxOutputStream(response,fileName); EasyExcel.write(xlsxOutputStream, classOb) .sheet(&quot;sheet1&quot;) .registerWriteHandler(new TitleSheetWriteHandler()) .doWrite(data); &#125; public static OutputStream getXlsxOutputStream(HttpServletResponse response, String fileName) throws IOException &#123; response.setContentType(&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); // 这里 URLEncoder 防止中文乱码// fileName = new String(fileName.getBytes(&quot;UTF-8&quot;),&quot;ISO8859-1&quot;); fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;); response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot;+ fileName + &quot;.xlsx&quot;); return response.getOutputStream(); &#125; public static OutputStream getXlsOutputStream(HttpServletResponse response,String fileName) throws IOException &#123; response.setContentType(&quot;application/vnd.ms-excel&quot;); response.setCharacterEncoding(&quot;UTF-8&quot;); // 这里 URLEncoder 防止中文乱码 fileName = URLEncoder.encode(fileName, &quot;UTF-8&quot;); response.setHeader(&quot;Content-disposition&quot;, &quot;attachment;filename=&quot;+ fileName + &quot;.xls&quot;); return response.getOutputStream(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128package com.university.report.common.utils;import com.alibaba.excel.metadata.CellData;import com.alibaba.excel.metadata.Head;import com.alibaba.excel.util.StyleUtil;import com.alibaba.excel.write.handler.CellWriteHandler;import com.alibaba.excel.write.metadata.holder.WriteSheetHolder;import com.alibaba.excel.write.metadata.holder.WriteTableHolder;import com.alibaba.excel.write.metadata.style.WriteCellStyle;import com.alibaba.excel.write.metadata.style.WriteFont;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import org.apache.commons.collections4.CollectionUtils;import org.apache.poi.ss.usermodel.*;import java.util.List;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/12 19:40 */@Data@AllArgsConstructor@NoArgsConstructorpublic class TitleSheetWriteHandler implements CellWriteHandler &#123; //操作行 private List&lt;Integer&gt; columnIndexs; //操作列 private List&lt;Integer&gt; rowIndexs; //颜色 private Short colorIndex; @Override public void beforeCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Row row, Head head, Integer columnIndex, Integer relativeRowIndex, Boolean isHead) &#123; &#125; @Override public void afterCellCreate(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead) &#123; &#125; @Override public void afterCellDataConverted(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, CellData cellData, Cell cell, Head head, Integer integer, Boolean aBoolean) &#123; &#125; @Override public void afterCellDispose(WriteSheetHolder writeSheetHolder, WriteTableHolder writeTableHolder, List&lt;CellData&gt; cellDataList, Cell cell, Head head, Integer relativeRowIndex, Boolean isHead) &#123; // 只处理第一行 Sheet sheet = writeSheetHolder.getSheet(); if( 0 == cell.getRowIndex())&#123; // 设置列宽 sheet.setColumnWidth(cell.getColumnIndex(), 20 * 256); // 设置行高 sheet.getRow(0).setHeight((short)(3*256)); // 获取workbook Workbook workbook = sheet.getWorkbook(); // 获取样式实例 WriteCellStyle headWriteCellStyle = new WriteCellStyle(); headWriteCellStyle.setWrapped(false); // 获取字体实例 WriteFont headWriteFont = new WriteFont(); // 设置字体样式 headWriteFont.setFontName(&quot;宋体&quot;); // 设置字体大小 headWriteFont.setFontHeightInPoints((short)14); // 边框 headWriteFont.setBold(true); headWriteCellStyle.setWriteFont(headWriteFont); // 设置背景颜色为蓝色 headWriteCellStyle.setFillPatternType(FillPatternType.SQUARES); headWriteCellStyle.setFillForegroundColor(IndexedColors.BLUE.getIndex()); if (CollectionUtils.isNotEmpty(columnIndexs) &amp;&amp; CollectionUtils.isNotEmpty(rowIndexs) &amp;&amp; colorIndex != null &amp;&amp; cell.getRowIndex() == 0 &amp;&amp; columnIndexs.contains(cell.getColumnIndex())) &#123; // 设置指定单元格字体自定义颜色 headWriteFont.setColor(colorIndex); &#125; // 获取样式实例 CellStyle cellStyle = StyleUtil.buildHeadCellStyle(workbook, headWriteCellStyle); // 单元格设置样式 cell.setCellStyle(cellStyle); &#125; //不处理第一行 if(0 != cell.getRowIndex())&#123; // 根据单元格获取workbook Workbook workbook = cell.getSheet().getWorkbook(); //设置行高 sheet.getRow(cell.getRowIndex()).setHeight((short)(2*256)); // 单元格策略 WriteCellStyle contentWriteCellStyle = new WriteCellStyle(); // 取消自动换行 contentWriteCellStyle.setWrapped(false); // 设置背景颜色白色 contentWriteCellStyle.setFillForegroundColor(IndexedColors.WHITE.getIndex()); // 设置垂直居中为居中对齐 contentWriteCellStyle.setVerticalAlignment(VerticalAlignment.CENTER); // 设置左右对齐为靠左对齐 contentWriteCellStyle.setHorizontalAlignment(HorizontalAlignment.LEFT); // 设置单元格上下左右边框为细边框 contentWriteCellStyle.setBorderBottom(BorderStyle.THIN); contentWriteCellStyle.setBorderLeft(BorderStyle.THIN); contentWriteCellStyle.setBorderRight(BorderStyle.THIN); contentWriteCellStyle.setBorderTop(BorderStyle.THIN); // 创建字体实例 WriteFont cellWriteFont = new WriteFont(); // 设置字体大小 cellWriteFont.setFontHeightInPoints((short)12); // 设置加粗 cellWriteFont.setBold(false); if (CollectionUtils.isNotEmpty(columnIndexs) &amp;&amp; CollectionUtils.isNotEmpty(rowIndexs) &amp;&amp; colorIndex != null &amp;&amp; rowIndexs.contains(cell.getRowIndex()) &amp;&amp; columnIndexs.contains(cell.getColumnIndex())) &#123; // 设置指定单元格字体颜色 cellWriteFont.setColor(colorIndex); &#125; contentWriteCellStyle.setWriteFont(cellWriteFont); CellStyle cellStyle = StyleUtil.buildHeadCellStyle(workbook, contentWriteCellStyle); cell.setCellStyle(cellStyle); &#125; &#125;&#125; 导出1234567891011121314151617@Overridepublic void exportData(HttpServletResponse response, String department, String dateString) &#123; try &#123; List&lt;ReportInfoVO&gt; infoVOList; if (StringUtils.isEmpty(dateString))&#123; infoVOList = reportInfoMapper.selectByDepNDateFull(department,null,null); ExcelUtils.exportExcel(response,infoVOList,ReportInfoVO.class,&quot;健康上报表&quot;,&quot;健康上报信息&quot;); return; &#125; List&lt;String&gt; onedays = TimeUtils.getOnedays(dateString); infoVOList = reportInfoMapper.selectByDepNDateFull(department,onedays.get(0),onedays.get(1)); ExcelUtils.exportExcel(response,infoVOList,ReportInfoVO.class,&quot;健康上报表&quot;,&quot;健康上报信息&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 导入1@Overridepublic void importUserAccount(MultipartFile file)&#123; try &#123; EasyExcel.read(file.getInputStream(),UserAccount.class,new UserImportListener(userAccountMapper)).sheet().doRead(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738package com.university.report.user.handler;import com.alibaba.excel.context.AnalysisContext;import com.alibaba.excel.event.AnalysisEventListener;import com.university.report.common.utils.MD5Util;import com.university.report.model.entity.UserAccount;import com.university.report.user.mapper.UserAccountMapper;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;/** * @ClassName health_report * @Author Jinondo * @Date 2021/7/1 8:19 */@Slf4jpublic class UserImportListener extends AnalysisEventListener&lt;UserAccount&gt; &#123; UserAccountMapper userAccountMapper; public UserImportListener(UserAccountMapper userAccountMapper) &#123; this.userAccountMapper = userAccountMapper; &#125; @Override public void invoke(UserAccount userAccount, AnalysisContext analysisContext) &#123; System.out.println(userAccount); userAccount.setPassword(MD5Util.encode(userAccount.getPassword())); userAccountMapper.insert(userAccount); userAccountMapper.insertOne(userAccount.getUserId(),Integer.parseInt(userAccount.getRoleName())); System.out.println(userAccount); &#125; @Override public void doAfterAllAnalysed(AnalysisContext analysisContext) &#123; &#125;&#125; 统一错误处理1234567891011121314151617181920212223242526272829package com.university.report.user.config;import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;import org.springframework.boot.web.server.ErrorPage;import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.HttpStatus;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/17 15:51 */@Configurationpublic class WebServerAutoConfiguration &#123; @Bean public ConfigurableServletWebServerFactory webServerFactory() &#123; TomcatServletWebServerFactory factory = new TomcatServletWebServerFactory(); ErrorPage errorPage400 = new ErrorPage(HttpStatus.BAD_REQUEST, &quot;/error/400&quot;); ErrorPage errorPage401 = new ErrorPage(HttpStatus.UNAUTHORIZED, &quot;/error/401&quot;); ErrorPage errorPage403 = new ErrorPage(HttpStatus.FORBIDDEN, &quot;/error/403&quot;); ErrorPage errorPage404 = new ErrorPage(HttpStatus.NOT_FOUND, &quot;/error/404&quot;); ErrorPage errorPage500 = new ErrorPage(HttpStatus.INTERNAL_SERVER_ERROR, &quot;/error/500&quot;); factory.addErrorPages(errorPage400, errorPage401, errorPage403, errorPage404, errorPage500); return factory; &#125;&#125; 统一返回结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475package com.university.report.common.result;/** * 统一返回结果状态信息类 * #200表示成功 * #1001～1999 区间表示参数错误 * #2001～2999 区间表示用户错误 * #3001～3999 区间表示接口异常 * #4001～4999 区间表示业务错误 * #5001～5999 区间表示部门错误 * #9001～9999 区间表示运行时异常 */public enum ResultCodeEnum&#123; // 统一状态码 SUCCESS(200,&quot;成功&quot;), FAIL(999, &quot;失败&quot;), /* 参数错误：1000～1999 */ PARAM_NOT_VALID(1001, &quot;参数无效&quot;), PARAM_IS_BLANK(1002, &quot;参数为空&quot;), PARAM_TYPE_ERROR(1003, &quot;参数类型错误&quot;), PARAM_NOT_COMPLETE(1004, &quot;参数缺失&quot;), /* 用户错误 */ USER_NOT_LOGIN(2001, &quot;用户未登录&quot;), USER_ACCOUNT_EXPIRED(2002, &quot;账号已过期&quot;), USER_CREDENTIALS_ERROR(2003, &quot;密码错误&quot;), USER_CREDENTIALS_EXPIRED(2004, &quot;密码过期&quot;), USER_ACCOUNT_DISABLE(2005, &quot;账号不可用&quot;), USER_ACCOUNT_LOCKED(2006, &quot;账号被锁定&quot;), USER_ACCOUNT_NOT_EXIST(2007, &quot;账号不存在&quot;), USER_ACCOUNT_ALREADY_EXIST(2008, &quot;账号已存在&quot;), USER_ACCOUNT_USE_BY_OTHERS(2009, &quot;您的登录已经超时或者已经在另一台机器登录，您被迫下线&quot;), USER_ACCOUNT_NEED_BIND(2010,&quot;请与系统账号进行绑定&quot;), DGUT_ACCOUNT_GET_FAIL(2011,&quot;莞工认证失败&quot;), /* 业务错误 */ NO_PERMISSION(4001, &quot;没有权限&quot;), /*数据获取失败*/ DATA_NOT_EXIST(5001, &quot;无数据可获取&quot;), TIMEFORMAT_ERROR(5002, &quot;时间格式必须为 yyyy-mm-dd&quot;), DEPLOYER_PERMIT_API(6001,&quot;开发者接口，请勿使用&quot;), REDIRECT_REQUEST(7002,&quot;重定向请求&quot;), REDIRECT_REQUEST_LOGIN_SUCCESS(7001,&quot;莞工登陆成功！&quot;), /*运行时异常*/ ARITHMETIC_EXCEPTION(9001,&quot;算数异常&quot;), NULL_POINTER_EXCEPTION(9002,&quot;空指针异常&quot;), ARRAY_INDEX_OUTOfBOUNDS_EXCEPTION(9003,&quot;数组越界&quot;), SERVER_ERROR(500,&quot;服务器错误&quot;); //LOGIN_ERROR( 23005, &quot;登录失败&quot;); private Integer code; private String message; ResultCodeEnum(Integer code, String message) &#123; this.code = code; this.message = message; &#125; public Integer getCode() &#123; return code; &#125; public String getMessage() &#123; return message; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116package com.university.report.common.result;import io.swagger.annotations.ApiModel;import io.swagger.annotations.ApiModelProperty;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;import lombok.experimental.Accessors;/** * 全局统一返回结果类 */@Data@ApiModel(value = &quot;全局统一返回结果&quot;)@AllArgsConstructor@NoArgsConstructor@Accessors(chain = true)public class Result&lt;T&gt; &#123; @ApiModelProperty(value = &quot;返回码&quot;) private Integer code; @ApiModelProperty(value = &quot;返回消息&quot;) private String message; @ApiModelProperty(value = &quot;返回数据&quot;) private T data; protected static &lt;T&gt; Result&lt;T&gt; build(T data) &#123; Result&lt;T&gt; result = new Result&lt;T&gt;(); if (data != null) &#123; result.setData(data); &#125; return result; &#125; public static &lt;T&gt; Result&lt;T&gt; build(T body, ResultCodeEnum resultCodeEnum) &#123; Result&lt;T&gt; result = build(body); result.setCode(resultCodeEnum.getCode()); result.setMessage(resultCodeEnum.getMessage()); return result; &#125; public static &lt;T&gt; Result&lt;T&gt; build(Integer code, String message) &#123; Result&lt;T&gt; result = build(null); result.setCode(code); result.setMessage(message); return result; &#125; public static&lt;T&gt; Result&lt;T&gt; ok()&#123; return Result.ok(null); &#125; /** * 操作成功 * @param data * @param &lt;T&gt; * @return */ public static&lt;T&gt; Result&lt;T&gt; ok(T data)&#123; Result&lt;T&gt; result = build(data); return build(data, ResultCodeEnum.SUCCESS); &#125; public static&lt;T&gt; Result&lt;T&gt; fail()&#123; return build(ResultCodeEnum.FAIL.getCode(), ResultCodeEnum.FAIL.getMessage()); &#125; /** * 操作失败，返回信息携带数据 * @param data * @param &lt;T&gt; * @return */ public static&lt;T&gt; Result&lt;T&gt; fail(T data,ResultCodeEnum resultCodeEnum)&#123; Result&lt;T&gt; result = build(data, resultCodeEnum); return result; &#125; /** * 操作失败，返回信息无数据 * @param resultCodeEnum * @param &lt;T&gt; * @return */ public static&lt;T&gt; Result&lt;T&gt; fail(ResultCodeEnum resultCodeEnum)&#123; Result&lt;T&gt; result = build(resultCodeEnum.getCode(), resultCodeEnum.getMessage()); return result; &#125; public Result&lt;T&gt; message(String msg)&#123; this.setMessage(msg); return this; &#125; public Result&lt;T&gt; code(ResultCodeEnum code)&#123; this.setCode(code.getCode()); return this; &#125; public boolean isOk() &#123; if(this.getCode().intValue() == ResultCodeEnum.SUCCESS.getCode().intValue()) &#123; return true; &#125; return false; &#125; public Result&lt;T&gt; data(T data) &#123; this.setData(data); return this; &#125;&#125; 其他工具类1234567891011121314151617181920212223242526272829303132333435363738package com.university.report.common.utils;import com.fasterxml.jackson.databind.ObjectMapper;import javax.servlet.ServletException;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/18 23:55 */public class JSONAuthentication &#123; /** * 输出JSON * @param request * @param response * @param data * @throws IOException * @throws ServletException */ public static void writeJSON(HttpServletRequest request, HttpServletResponse response, Object data) throws IOException, ServletException &#123; //这里很重要，否则页面获取不到正常的JSON数据集 response.setContentType(&quot;application/json;charset=UTF-8&quot;); response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); response.setHeader(&quot;Access-Control-Allow-Method&quot;, &quot;POST,GET&quot;); //输出JSON PrintWriter out = response.getWriter(); out.write(new ObjectMapper().writeValueAsString(data)); out.flush(); out.close(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.university.report.common.utils;import org.apache.commons.lang3.time.DateFormatUtils;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.TimeZone;/** * @ClassName health_report * @Author Jinondo * @Date 2021/6/20 11:43 */public class TimeUtils &#123; public static Date stringToDate(String dateStr)&#123; SimpleDateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); Date date = null; try &#123; date = format.parse(dateStr); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; return date; &#125; public static Long stringToTime(String dateStr)&#123; Date date = stringToDate(dateStr); return date.getTime(); &#125; public static Date timeToDate(Long time)&#123; Date date = new Date(); date.setTime(time); return date; &#125; public static String timeToString(Long time)&#123; Date date = timeToDate(time); SimpleDateFormat simpleDateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;); return simpleDateFormat.format(date); &#125; /** * 获取 今天零点零分零秒 和 今天23点59分59秒 * @return */ public static List&lt;String&gt; getTodays()&#123; //当前时间毫秒数 long current=System.currentTimeMillis(); //今天零点零分零秒的毫秒数 long zero=current/(1000*3600*24)*(1000*3600*24)- TimeZone.getDefault().getRawOffset(); // 今天23点59分59秒的毫秒数 long twelve=zero+24*60*60*1000-1; String from = DateFormatUtils.format(new Date(zero), &quot;yyyy-MM-dd HH:mm:ss&quot;); String to = DateFormatUtils.format(new Date(twelve), &quot;yyyy-MM-dd HH:mm:ss&quot;); ArrayList&lt;String&gt; todays = new ArrayList&lt;String&gt;(2) &#123;&#123; add(from); add(to); &#125;&#125;; return todays; &#125; /** * 获取 某天零点零分零秒 和 某天 23点59分59秒 * @return */ public static List&lt;String&gt; getOnedays(String timeString)&#123; timeString = timeString + &quot; 00:00:00&quot;; //当前时间毫秒数 Long zero = stringToTime(timeString); //今天零点零分零秒的毫秒数 // 今天23点59分59秒的毫秒数 long twelve=zero+24*60*60*1000-1; String from = DateFormatUtils.format(new Date(zero), &quot;yyyy-MM-dd HH:mm:ss&quot;); String to = DateFormatUtils.format(new Date(twelve), &quot;yyyy-MM-dd HH:mm:ss&quot;); ArrayList&lt;String&gt; oneDays = new ArrayList&lt;String&gt;(2) &#123;&#123; add(from); add(to); &#125;&#125;; return oneDays; &#125;&#125; 注意事项 如果打包后没有mapper文件或者yml文件，就到pom里加上 时间类使用jdk8提供的新类：LocalDate，LocalDateTime 等 对于频繁查询的键加个索引(这里其实需求不大，加索引反而不好)：ALTER TABLE t_report_info ADD INDEX (department); UserInfo 表可能不需要有主键？ 使用security时不要默认实现Userdetails的方法，或者把它们返回true！！！ 路径应该分类为 /api/**,/admin/** 每次更改api注释修改更新时间 打包的时候一定要在pom里包含resources下的文件 SET SQL_SAFE_UPDATES = 0; java -jar .\\service-user-0.0.1-SNAPSHOT.jar –server.port=8085 nohup java -jar service-user-0.0.1-SNAPSHOT.jar –server.port=8085 &gt; service-user-log.txt &amp; netstat -nlp | grep :8080","categories":[{"name":"Java","slug":"Java","permalink":"https://jinondo.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jinondo.github.io/tags/Java/"},{"name":"Springboot","slug":"Springboot","permalink":"https://jinondo.github.io/tags/Springboot/"}]},{"title":"iconfont使用","slug":"iconfont使用","date":"2021-07-05T15:00:58.000Z","updated":"2021-07-05T15:00:58.000Z","comments":true,"path":"2021/07/05/iconfont使用/","link":"","permalink":"https://jinondo.github.io/2021/07/05/iconfont%E4%BD%BF%E7%94%A8/","excerpt":"","text":"记录一下通过iconfont获取unicode码并运用的方法 网址：https://www.iconfont.cn/ 第一步：在阿里巴巴矢量图标网站上可以查看图标。 第二步：点击一个图标或者一个图标集合，添加入库 第三步：在库里添加到项目里，下载到本地 第四步：查看文件，里面有使用方法（demo_index.html中） 第五步：可以通过字体文件查看该字体下有多少图标及其unicode码 这里给出一个网站：http://blog.luckly-mjw.cn/tool-show/iconfont-preview/index.html","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://jinondo.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"iconfont","slug":"iconfont","permalink":"https://jinondo.github.io/tags/iconfont/"}]},{"title":"JVM学习笔记","slug":"JVM-Note","date":"2021-05-22T15:04:00.000Z","updated":"2021-05-22T15:04:00.000Z","comments":true,"path":"2021/05/22/JVM-Note/","link":"","permalink":"https://jinondo.github.io/2021/05/22/JVM-Note/","excerpt":"","text":"Interview JVMps: 本笔记记录宋红康JVM教程 虚拟机栈 每个栈帧中存储着： 局部变量表 Local Variables 操作数栈 Operand stack 动态链接 Dynamic Linking 方法返回地址 Return Address 一些附加信息 内部保存一个个栈帧，对应着一次次的java方法调用 作用：主管java程序的运行，它保存方法的局部变量（8种基本数据类型，对象的引用地址），部分结果，并参与方法的调用和返回。 设置栈大小 -Xss 局部变量表 在局部变量表里，32位以内的类型占用一个 slot，64位的类型（long和double）占用两个slot 一个面试题： 12345678910111213public static void main(String[] args) throws Exception &#123; int i1 = 10; i1 = i1++; int i2 = 10; i2 = ++i2; System.out.println(i1 +&quot;---&quot;+i2); int i3 = 10; int i4 = i3++ + ++i3; System.out.println(i3 +&quot;---&quot;+i4);&#125; 1210---1112---22 栈中可能会出现的异常Java虚拟机规范允许Java栈的大小是动态的或者是固定不变的。 如果采用固定大小的java虚拟机栈，那每一个线程的java虚拟机栈容量可以在线程创建时候独立选定。如果线程请求分配的栈容量超过jvm允许的最大容量，jvm将会抛出 StackOverFlowError 异常 如果栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，则jvm将会抛出一个 OutOfMemoryError 异常。 动态链接在JVM中，将符号引用转换成调用方法的直接引用与方法的绑定机制相关 静态链接，被调用的目标方法在编译期可知，且运行期保持不变 动态链接，只能够在运行期将调用方法的符号引用转换为直接引用。 早起绑定 vs 晚期绑定 非虚方法 如果方法在编译期就确定了具体的调用版本，这个版本在运行时不可变，这样的方法叫做非虚方法 静态方法，私有方法，final方法，实例构造器，父类方法都是非虚方法 其他方法称为虚方法 虚拟机提供的方法调用指令 普通调用指令： invokestatic 调用静态方法，解析阶段确定 invokespecial 调用&lt;init&gt; ，私有及父类方法，解析阶段确定 invokevirtual 所有虚方法 invokeinterface 接口方法 动态调用指令： invokedynamic （jdk7）动态解析出需要调用的方法，然后执行 invokestatic 和 invokespecial 称为非虚方法，其余（final修饰除外，final使用invokevirtual）称为虚方法 关于 invokedynamic ： 在java7中需要借助工具生成该指令，直到在java8的lambda表达式中可以直接生成该指令。java是静态语言类型，这个只是让java增加了动态语言的功能。 方法的重写 &amp; 虚方法表 简单说就是得到这个方法名称，看这个类中有没有和这个名称和描述相同的方法，没有就一层层向父类去搜索和验证，故提高性能就是用了虚方法表（非虚方法不需要表，因为已经编译期确定了） 例如： 堆 每一个 JVM 实例只存在一个堆内存 堆里除了放对象实例，也可能会放引用（例如成员变量，它的实体和引用都放在堆里，如果是方法中的局部变量，则引用放在栈里的局部变量表里） 运行时参数调整整体堆大小 调参： -Xms -Xmx (初始堆空间，最大堆空间) ms：memory start，mx：memory max（我猜的） 运行参数的堆大小在实际中一般都设一样的，防止频繁调整堆大小而消耗系统性能 查看设置的参数： 方式1: jps 查看进程号， jstat -gc 进程id 方式2：-XX:+PrintGCDetails 配置新生代与老年代在堆结构的占比 :one: 默认 -XX:NewRatio = 2，表示新生代占1，老年代占2，新生代占整个堆的1/3 :two: 可以修改 -XX:NewRatio = 4，表示新生代占1，老年代占4，新生代占整个堆的1/5 也可以直接设置 -Xmn 设置新生代空间的大小 (如果和占比同时设置了，就以-Xmn为准) 设置Eden和Survivor的比例 默认比例是8:1:1；但是jvm有个自适应机制，所以测试默认会是6:1:1，可以同通过修改 -XX:-UseAdaptiveSizePolicy来关闭自适应的内存分配策略，但是！事实设置了并没有效果。 正确设置比例应该使用 -XX:SurvivorRatio=8 对象分配过程 new的对象先放在伊甸园区，此区有大小限制。 当伊甸园的空间填满时，程序又需要创建对象，JVM的垃圾回收期对伊甸园区进行GC（minor GC 或者 YGC）。 GC后将伊甸园区的剩余对象，即幸存者，移动到幸存者0区，并把 age 设置为1,。 如果再次触发垃圾回收，还是一样伊甸园区进行GC，剩余对象放到幸存者1区（就是幸存者中空的区，空的就是to区，另一个是from区），Minor GC会触发幸存者0区的GC，把0区的不再被引用的对象销毁后，剩余的对象放到幸存者1区，此时把对象的年龄再加1，此时0区又变成了to区。 当幸存者区中的年龄为15时（默认情况），则在发生GC时会被进入老年区。可以设置该参数 -XX:MaxTenuringThreshold=&lt;N\\&gt; 如果一个要分配一个大对象，在minorGC完后伊甸园区已经空了，但还是放不下，就直接移送到老年区，如果老年区这时候还放不下，就进行fullGC或者说MajorGC。假如还是放不下这个对象，则报 OOM。 还有一种情况，当发生GC时，要把对象移送到幸存者区时，幸存者放不下，则移送到老年代（:question: 是哪个对象移送到老年代 ? ） 动态对象年龄判断：如果幸存者区中相同年龄的所有对象大小的综合大于幸存者空间的一半，年龄大于或等于该年龄的对象可用直接进入老年代，无需等到阈值中要求的年龄，因为s1和s0的复制算法也是需要耗性能。 关于垃圾回收：频繁在新生区收集，很少在养老区收集（第一，养老区空间大，第二，对象都是不太可能被清除的对象），几乎不再永久区/元空间收集。 三种GC类型垃圾回收对象为三个内存区域（新生代，老年代，方法区），大部分GC都是指新生代的回收，老年代的回收比较占性能，所以调优主要针对MajorGC和FullGC。 针对HotSpot VM的实现，GC按照回收区域又分为两大类型，一种是部分收集（Partial GC），一种是整堆收集（Full GC） :one: 部分收集 新生代收集（Minor GC / Young GC） 老年代收集 （Major GC / Old GC） 目前，只有CMS GC会有单独收集老年代的行为 注意，很多时候Major GC会和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收。 混合回收（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集 目前，只有G1 GC会有这种行为 :two: 整堆收集（Full FC）：收集整个java堆和方法区的垃圾收集。 年轻代GC：当新生代满的时候触发，这里的新生代指 Eden区，幸存者区满了不会触发！！！ 老年代GC： 出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程），也就是说在老年代空间不足时，会先尝试触发Minor GC，如果之后空间还不足，则触发Major GC（这里有点疑问，Minor GC会去清老年代的对象？？？） 老年代GC比新生代GC慢10倍以上，STW时间更长 GC之后还是内存不足，就报 OOM。 Full GC触发机制： 调用 System.gc() ，系统建议执行 Full GC，但是不必然执行 老年代空间不足 方法区空间不足 通过Minor GC后进入老年代的平均大小小于老年代的可用内存。 TLABThread local allocation buffer 从内存模型而不是垃圾收集的角度，对Eden区继续进行划分，JVM为每个线程分配了一个私有缓存区域，它包含在Eden空间内。 尽管不是所有的对象实例都能在TLAB中成功分配内存，但JVM确实是将TLAB作为内存分配的首选 -XX:+UserTLAB 开启，默认也是开启的 默认占整个伊甸园空间的1%，可以改参数 一旦对象在TLAB分配内存失败，jvm就会尝试着通过加锁机制确保数据操作的原子性，从而直接在Eden空间中分配内存。 参数总结 空间分配担保 在发生MinorGC之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象的总空间， 如果大于，则此次MinorGC是安全的 如果小于，则看-XX:HandlePromotionFailure 设置值是否允许担保失败 如果为True，则会继续检查老年代可用连续空间是否大于历次晋升到老年代的对象的平均大小 如果大于：则尝试进行一次Minor GC，这次YGC依然有风险 如果小于，则进行一次Full GC 如果为False，则直接进行一次Full GC 在JD7及以后的版本，该参数不会影响到这个策略了，虽然还是定义了这个参数，但源码中显示不会用到。 规则为：只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会Minor GC，否则Full GC 堆是分配对象的唯一选择吗？逃逸分析 在即时编译器编译优化阶段进行。 当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。 当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。 如果不发生逃逸，可以考虑栈上分配，随着方法执行的结束，栈空间就被移除。 使用逃逸分析，编译器可以对代码做如下优化： 栈上分配。将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配 同步省略（锁消除）。如果一个对象被发现只能从一个线程被访问到，那么对这个对象的操作可以不考虑同步。例如你锁的对象每次都是new出来的。 分离对象或标量替换。 结论：对象实例都是分配在堆上的！ 上面提到的逃逸分析栈上分配，技术不算十分成熟，故其实不被应用，上面的例子看到的效果其实都是基于标量替换而已，并没有进行对象的栈上分配（对象分离出来了就不是对象了，当然就在栈上）。 而且后来的元空间中字符串常量池和静态变量也分配到了堆上，也进一步说明对象实例就是分配在堆上的。 方法区 1.7 的方法区叫永久代，分配在java内存中，导致很容易触发OOM，1.8换成元空间，且分配在本地内存上，则不容易发生OOM -XX:MetaspaceSize 可以设置初始元空间大小，或者设置最大： -XX:MaxMetaspaceSize ,初始值为初始的高水位线，会根据Full GC后释放的空间大小来上下调整这个高水位线，所以为了避免多次GC，可以一次性元空间大小设置为一个相对较高的值。 储存内容用于储存已被虚拟机加载的类型信息，常量，静态变量（只是引用而已，数据肯定还是存放在堆中），域信息，方法信息，即时编译器编译后的代码缓存等。 这个方法信息中存有方法的字节码，操作数栈和局部变量表的大小信息等。 方法区中还存有这个类加载进来时所使用的类加载器信息！ 其中如果是non-final的类变量，也是成为类数据在逻辑上的一部分 如果是 final static的，则在prepare阶段就已经初始化了值（不是指初始化为0那种初始化，我们知道在链接的prepare阶段会初始化0，如int值，在初始化阶段才会去初始化值，指代码中写的初始化值）。 运行时常量池 vs 常量池字节码文件中时常量池,通过类加载器加载到内存的方法区中就是运行时常量池，常量池里放的是字符引用，但运行时常量池则具有动态性，它换成了真实的地址。 为什么需要运行时常量池 因为常量池表中有各种字面量和对类型和方法的符号引用,java中的字节码需要数据支持,但数据太大不能存到字节码里,所以用符号引用,在动态链接时可以使用到常量池。 方法区和栈的调用： 可以看出字节码是放在方法区中的。 方法区变迁为什么要把永久代换成元空间 为永久代设置空间大小是很难确定的，某些场景下功能多，要不断动态加载很多类，例如导入很多jar包，容易产生OOM 对永久代调优困难，因为很难确定一个类还需不需要用到，再进行Full GC 为什么要把字符串常量池放到堆里， 从JDK7就开始这么做了，是因为永久代的回收效率比较低，只有在FullGC时触发，但很少会有FullGC，而开发中会有大量字符串被创建，回收效率很低，导致永久代内存不足。放到堆里，就能及时回收内存。 方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。 关于静态变量java7以后选择把静态变量与Class对象都放在堆里。 关于对象创建对象的方式 new 最常见的方式 变形1：Xxx的静态方法（单例模式） 变形2：工厂类的静态方法 Class的newInstance() 反射的方式，只能调用空参的构造器，权限必须是public（jdk9过时） Constructor的newInstance（Xxx） 反射的方式，可以调用空参、带参的构造器，权限没有要求 使用clone（）不调用任何构造器，当前类需要实现Cloneable接口，实现clone（） 使用反序列化，从文件中，从网络中获取一个对象的二进制流 第三方库Objenesis 虚拟机遇到一条new指令，首先去检查这个指令的参数能否在元空间的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载链接和初始化（即判断类元信息是否存在），如果没有，就在双亲委派机制下，使用当前类加载器以ClassLoader+包名+类名为key找到对应的class文件，如果没有找到文件，则抛出ClassNotFoundException。如果找到，则进行类加载，并生成对应的Class类对象。 为对象分配内存，规整不规整的问题，选择哪种分配方式有Java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。 处理并发安全问题 初始化分配到的空间，主要是指“零值初始化”： 给对象的属性赋值： 属性的默认初始化 显示初始化 / 代码块中初始化 构造器中初始化 指上方的第一点，属性的默认初始化 5.设置对象头：将对象的所属类（类的元数据信息）、对象的HashCode和对象的GC信息，锁信息等数据储存在对象的对象头中，这个过程的具体设置方式取决于JVM实现。 6.执行init初始化，指上面的2和3：显示初始化 / 代码块中初始化 和 构造器中初始化 对象的内存布局 例子： 对象的定位主要有两种定位方式： 句柄访问 直接指针（Hotspot默认） 优缺点： 句柄访问优点是在更改对象实例的地址时，栈里的本地变量表不需要做修改；缺点就是得咋堆里再开一块空间放句柄池 直接指针优点是不需要在堆里额外开空间；缺点则是在更改对象实例的地址时，栈里的本地变量表需要做修改。 直接内存不是虚拟机运行时数据区的一部分。来源于NIO，通过存在堆中的DirectByteBuffer操作native内存 ByteBuffer byteBuffer = ByteBuffer.allocateDirect(1); 123public static ByteBuffer allocateDirect(int capacity) &#123; return new DirectByteBuffer(capacity);&#125; :1st_place_medal: 优点：读写性能高 本地内存也可能导致OOM，受限与系统内存，当然也可以调参数 缺点： 分配回收成本高；不受JVM内存回收管理。 执行引擎执行引擎的工作过程 从外观上看，所有的java虚拟机的执行引擎输入、输出都是一致的：输入的是字节码二进制流，处理过程是字节码解析执行的等效过程，输出的是执行结果。总的来说，执行引擎就是翻译字节码指令为机器能识别的指令。 理解解释器和编译器 解释器是对字节码逐行解释为机器指令让机器运行 编译器是将源代码直接编译成本地机器相关的机器语言，而且有一个热点探测功能和代码缓存，热点探测分两种，方法调用计数器（将超过计数器阈值的代码做缓存）和回边计数器（统计循环体代码执行次数）。 在Hotspot有两个JIT编译器，分为Client Compiler 和 Server Compiler 简称为C1和C2。像之前说的逃逸分析，标量替换，同步消除是C2编译器的优化策略。 垃圾回收标记阶段标记阶段有两种标记算法： :one: 引用计数法优点不用多说了，实现简单，垃圾对象便于辨识，判定效率高，回收没有延迟性。 缺点： 增加了存储空间开销 增加时间开销 主要缺点！：无法处理循环引用，致命缺陷，导致java的垃圾回收器中没有使用这类算法 python 就同时支持引用计数和垃圾收集机制 如何解决循环引用呢？ 手动解除 使用弱引用 weakref :two: 可达性分析 在 java 中，GC roots 包括以下几类元素 虚拟机栈中引用的对象 本地方法栈中引用的对象 方法区中类静态属性引用的对象（如果不是静态是放在堆里的） 方法区中常量引用的对象（例如字符串常量池里的引用） 所有被同步锁synchronized持有的对象 虚拟机内部的引用（基本数据类型对应的Class对象，常驻异常对象，系统类加载器） 其他。。。 上面图片第一点：例如分代垃圾回收对新生代回收，那么老年代也可能有对新生代中对象的一个引用，所以也要把老年代中的引用看成GC Roots。 finalize永远不要主动调用finalize方法，应该交给垃圾回收机制调用。 理由： 在finalize 时可能会导致对象复活 finalize 的执行试驾时间是没有保障的，完全有GC线程决定，极端情况下，若不发生GC，则finalize方法将没有执行机会 一个糟糕的finalize会严重影响GC性能，所以交由GC去做，在必要的时候会去调用。 网上：尽管finalize()可以主动调用, 但是最好不要主动调用, 因为在代码中主动调用之后, 如果JVM再次调用, 由于之前的调用已经释放过资源了,所以二次释放资源就有可能出现导致出现空指针等异常, 而恰好这些异常是没有被捕获的, 那么就造成对象处于被破坏的状态, 导致该对象所占用的某一部分资源无法被回收而浪费. 对象的三种状态 可触及的：从根节点开始，可以到达这个对象。 可复活的：对象的所有引用都被释放，但是对象有可能在finalize 中复活 不可触及的：对象的 finalize 被调用，并且没有复活，那么就会进入不可触及状态。不可触及状态不可能被复活，因为finalize只会被调用一次 以上只有在对象不可触及时才可以被回收。 查看GCRoots的工具：用jvisualm导出dump，然后用Eclipse MAT打开dump查看 或者用JProfiler进行GCroots溯源 清除阶段清除阶段有三种算法： 标记-清除算法 Mark Sweep 复制算法 Copying 标记-压缩算法 Mark Compact :one: 标记清除算法 执行过程： 当堆中有效内存空间被耗尽时，先STW，然后进行标记和清除 标记：Collector 从引用根节点开始遍历，标记所有被引用的对象（注意！是标记被引用的），一般是在对象头里记录 清除：Collector 从堆内存进行线性遍历，发现某个对象的Header里没有标记为可达的，则将其回收。 缺点： 效率不算高，需要两次遍历 STW 内存碎片，需要维护空闲列表（额外空间消耗） 清除并不是真正的置空，只是把这个地址记录在空闲列表中。 :two: 复制算法 看图： 检索到有引用关系就直接复制，没有标记和清除过程 优点： 没有标记和清除过程，实现简单，运行高效（主要优点） 没有碎片问题 缺点： 需要两倍空间 对于G1这种拆分成为大量region的GC，复制需要维护region之间的对象引用关系，内存占用和时间开销不小（可以参考堆的直接指针引用那块知识，对象地址换了就得更改栈中数据） 使用于存活对象数量小的情况，你想想GC完全都存活又得复制一遍，是不是 :cry: 所以用于年轻代的s0和s1区（朝生夕死），很合理。 :three: 标记-压缩算法 也成为标记-清除-压缩算法 执行过程： 第一阶段就标记，和标记清除一样 第二阶段把所有存活对象压缩到内存的一端，按顺序排放 之后，清理边界外所有的空间 优点： 消除标记-清除算法的缺点：直接用指针碰撞，不需要维护空闲列表 消除复制算法的缺点：内存减半 缺点： 效率低于复制算法 移动对象时，该对象的引用得改 STW 三种算法各有各的优势，所以HotSpot的垃圾回收器一般都用分代的垃圾回收机制。 增量收集算法 和 分区算法思路 以上算法都会STW，所以有了这两种算法 增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过对线程间冲突的妥善处理。允许垃圾收集线程以分阶段的方式完成标记、清除或复制工作。（缺点：线程切换和上下文转换，吞吐量下降） 分区算法将整个堆空间划分成连续的不同小区间。每个小区间都独立使用，独立回收。好处是可以控制一次回收多少个小区间 相关概念System.gc()System.gc() 底层是： 123public static void gc() &#123; Runtime.getRuntime().gc();&#125; 并不保证一定执行。 1System.runFinalization(); // 强制调用 对象的finalize方法 题目： 1234567891011121314一个方法：&#123; int[] a = new int[1024*1024];&#125;System.gc(); // 此时并不会把上面的a给回收掉// 查看class文件，局部变量表的长度为2，一个是this，另一个就是这个a，但没有显示出来而已。另一个方法：&#123; int[] a = new int[1024*1024];&#125;int b = 1;System.gc(); // 这个时候会把a给回收掉// 涉及到变量表里的覆盖功能。 内存泄漏Memory leak 内存溢出不用多说了，原因有2，一个是堆大小设置不合理，一个是创建了太多对象 内存泄漏严格上说，是一个对象不会再被用到了，但GC不能回收他们，称为内存泄漏 宽泛意义上说，一些不太好的代码创建了一个声明周期很长的对象，也可以交内存泄漏 例子： 单例模式，单例的声明周期一般和应用程序一样长，如果单例中持有其他对象的，那么这个外部对象是不能被回收的，导致内存泄漏。 一些提供close的资源没有关闭导致泄漏，例如数据库连接，socket和io，必须手动close。 （宽泛意义）比如你把一些应该是局部变量的数据放到了对象属性上，甚至设置了static；或者把一些不必要的对象放在session，或者会话级别上，也算宽泛的内存泄漏。 安全点和安全区域安全点：在特定位置可以停下来GC 抢占式中断（目前没有虚拟机采用）：先中断，如果还有线程没到安全点，在让这些线程启动跑到安全点 主动式中断：设置一个中断标志，各个线程运行到safe point时主动轮训这个标志，如果标志为真，则将自己进行中断挂起 安全区域：在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。 执行： 当线程运行到safe region的代码时，首先表示进入了安全区，这段时间发生GC的话，JVM会忽视表示为safe region状态的线程 当线程即将离开安全区是，如果已经完成GC，就继续运行，如果没有，则线程等待直到收到可以安全离开safe region的信号为止。 关键是能让程序进行安全的GC，我的理解是安全点是让线程停在点上，区域是说可以让线程继续跑，因为没有引用变化。 强软弱虚 强引用：不回收 软引用：内存不够就回收，内存够不回收（高速缓存就有用到弱引用），这个内存不够可能指报OOM之前，也可能不报OOM。 这里就讲到：只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行二次回收。注意这里的二次回收，也就是说在第一次普通回收之后，会发现内存还是不足，这时候会去回收软引用关联的对象，在回收之后可能不会报OOM，也可能会报OOM。 弱引用：发现即回收，只被弱引用关联的对象只能生存到下一次垃圾收集发生为止，软引用、弱引用都非常适合来保存那些可有可无的缓存数据。（这里有个WeakHashMap，底层的Entry就是继承了弱引用） 虚引用：一个对象如果仅持有虚引用，那么和没有引用几乎是一样的，无法通过虚引用来获取对象，get出来是null。 目的在于跟踪垃圾回收过程。 终结器引用：和finalize有关 引用都会涉及到一个引用队列去管理。 垃圾回收器分类： 按线程数分，分为串行垃圾回收器和并行垃圾回收器。指GC的线程。 按工作模式分，分为并发式和独占式。并发式是指并发垃圾回收器和应用程序交替工作，以尽可能减少应用程序的停顿时间；独占式就STW。 按碎片处理方式。 按工作的内存区间。 性能指标 现在的标准是，保证了停顿时间，去最大程度加大吞吐量。 几种垃圾回收器 图片截止至JDK14 JDK8中使用的是 parallel scavenge GC 和 parallel old GC。 JDK9默认使用 G1GC Serial 回收器：串行回收 最基本，历史最悠久 Hotspot 虚拟机中 Client模式下的默认新生代垃圾收集器 Serial 收集器采用复制算法，串行回收和STW机制执行内存回收 对于老年代有一个 Serial Old 收集器，一样是串行回收和STW，但对于老年代是用标记-压缩算法。 Serial Old是Client模式的默认老年代回收器 Serial Old在server模式下也有用途：1. 与新生代的parallel scavenge配合使用 2. 作为老年代CMS的后背垃圾收集方 在单核CPU环境来说非常好 ParNew 回收器：并行回收就是Serial的并行版本。配合使用情况见上图。 Parallel Scavenge 收集器：吞吐量优先JDK8 默认 大概机制和 ParNew 回收器 一致，但不用的是： 达到一个可控制的吞吐量。 有自适应调节策略。 高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适用于后台运算而不需要太多交互的任务。因此经常在服务器环境中使用。例如执行批处理，订单处理，工资支付，科学计算的应用程序。 JDK1.6时老年代使用了Parallel Old， 代替那个串行的Serial Old。 也是标记压缩，并行回收和STW。 一些指定参数（这就是吞吐量优先的原因）： -XX:ParallelGCThreads 设置年轻代并行收集器的线程数 -XX:MaxGCPauseMills 设置收集器最大停顿时间（使用需谨慎，因为可能吞吐量会下降） -XX:GCTimeRatio 设置垃圾收集时间栈总时间的比例 (= 1 / (N+1) )。设置这个N，范围（1,100），默认99，即垃圾回收时间不超过1%。 -XXUseAdaptiveSizePolicy 设置自适应，例如年轻代大小，伊甸园和幸存者的比例，晋升老年代的年龄都自适应调整。 CMS 垃圾回收器Concurrent Mark Sweep Hotspot中第一款真正意义上的并发收集器，第一次实现让垃圾收集线程和用户线程同时进行。关注点是尽可能降低用户线程的停顿时间。 采用 标记-清除 算法 也会STW 在G1出现之前应用广泛 对于老年代的收集，配合使用见上图 初始标记：只是标记和GC Root直接相关联的对象，速度较快，STW时间短 并发标记：遍历整个对象图和引用链 重新标记：因为上个阶段是并发，所以可能引用会有一些变化，但变化不大，（这里重新标记可能是标记那些上一阶段没有被标记的对象？）STW时间较短 并发清除：清理已经死亡的对象，不需要更改到存活对象，也就可以并发。 重置线程 由于并发操作，导致不能再堆真的满了的情况下去进行GC，达到一个阈值就需要GC，如果预留内存无法满足程序需要，则出现Concurrent Mode Failure，此时就得启用预备方案：Serial Old 由于是并发清除，所以不能用Compact，会造成内存碎片 优点： 并发收集 低延迟 缺点： 内存碎片 占用CPU资源，总吞吐量降低 无法处理浮动垃圾。 相关参数： 设置堆使用的内存阈值 指定执行Full GC后进行内存压缩整理 设置CMS线程数量 G1 回收器JDK9默认垃圾回收器 G1 跟踪各个 Region 里面的垃圾堆积的价值（回收所获得的空间大小及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。 优势： 并行与并发：可以有多个GC线程同时工作，此时用户线程STW；可以有工作线程和应用程序同时执行。 分代收集，同时兼顾年轻代和老年代 空间整合 CMS：”标记-清除“算法、内存碎片在若干次GC后进行一次碎片整理 G1：Region之间是复制算法，整体看做 标记-压缩，两种算法都可避免内存碎片。当Java堆非常大时，G1优势更明显 可预测的停顿时间模型（软实时 soft real-time） 可以控制消耗在垃圾收集上的时间 G1只选取部分区域进行内存回收，这样缩小了回收的范围，对于全局停顿情况的发生也能得到较好的控制。比如我限制停顿200ms，GC就会去找符合要求的区域进行回收。 维护一个优先列表，按照回收价值回收。 经验上看，小内存应用上CMS表现优于G1，G1大内存上发挥优势，平衡点再6-8GB。 参数 设置每个Region大小：1MB - 32 MB，目标是根据最小的Java堆大小划分出2048个区域。默认是堆内存的1/2000 设置期望达到的停顿时间指标（JVM尽力实现，不保证达到），默认200ms 设置STW时GC线程数 设置并发标记的线程数 设置触发GC周期的堆占用率阈值，默认45。 操作 第一步：开启G1 第二步：设置堆最大内存 -Xms -Xmx 第三步：设置最大停顿时间 最好不要设置年轻代大小 -XX:Newratio，可能会覆盖暂停时间 G1提供了：YoungGC、Mixed GC 和 Full GC，在不同条件下被触发。 应用场景 在下面的情况时，使用G1可能比CMS好： 超过50%的java堆被活动数据占用 对象分配频率或年代提升频率变化很大 GC停顿时间过长（长于0.5至1秒） Hotspot 垃圾收集器里，除了 G1以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1GC 可以采用应用线程承担后台运行的 GC工作，即当 JVM 的GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。 Region只能是Eden、Survivor、Humongous中的一种，但是它的身份不是固定的，谁来占用那么这个Region就是谁的. Humongous区，主要用于存储大对象，如果超过0.5的region就放入H区。 设置H区的原因：如果存在短期存在的大对象，直接放入老年代有负面影响。 依然具有指针碰撞 （region内） 依然有TLAB：虽然存在分区Region，但是依然有线程独有的TLAB空间，这样可以保证多个线程对对象修改可以并行操作 过程 包括三个环节： 年轻代GC 老年代并发标记过程 Concurrent Marking 混合回收 Mixed GC （如果需要，可能会触发单线程，独占式，高强度的Full GC） 具体： 年轻代回收 :arrow_right: 年轻代GC + 并发标记 :arrow_right: 混合回收（不是FullGC） 内容太多了，这里只记录重点 当年轻代的Eden区用尽（应该是指的所有eden区）时开始YGC。是一个并行的独占式收集器，复制算法，和survivor区结合进行。（涉及Eden区和Survivor区的回收） 这里会涉及到 remembered set，因为老年代中可能也也有引用指向年轻代，所以每个region有一个 rset，避免全局扫描，rsets数据是由card table来的。这也是G1的一个小缺点 最后有个阶段是回收软弱虚final，JNI weak等引用 当堆内存使用到一定值（默认45%）进行老年代并发标记过程 初始标记根节点直接可达对象 STW 根区域扫描：扫描幸存者区的直接可达的老年代区域对象。（在 minor GC 前） 并发标记。（如果发现整个区域是垃圾，直接回收） 再次标记 STW 独占清理 STW 并发清除（针对于：如果发现整个区域是垃圾，直接回收） 标记完进行混合回收，其中的老年代回收会根据回收价值（有一个阈值，垃圾占比，默认65%）去优先队列取小部分老年代region，而不是所有 GC日志 未来发展：ZGC jinfo -flag NewRatio pid 可以查看设置的jvm参数，NewRatio 可以替换","categories":[{"name":"Java","slug":"Java","permalink":"https://jinondo.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jinondo.github.io/tags/Java/"}]},{"title":"哈希表与字符串","slug":"哈希表与字符串","date":"2021-03-03T11:52:15.000Z","updated":"2021-03-03T11:52:15.000Z","comments":true,"path":"2021/03/03/哈希表与字符串/","link":"","permalink":"https://jinondo.github.io/2021/03/03/%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"本文章记录一些 LeetCode 题目，是我学习b站小象学院视频教程所做笔记，文末注明教程出处。侵删 ¯\\_( ͡° ͜ʖ ͡°)_/¯ 哈希表与字符串1. LeetCode 409 最长回文串题目描述给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。 注意:假设字符串的长度不会超过 1010。 示例 1: 输入:“abccccdd” 输出:7 解释:我们可以构造的最长的回文串是”dccaccd”, 它的长度是 7。 解决1234567891011121314151617181920212223class Solution &#123; public int longestPalindrome(String s) &#123; Integer[] char_map = new Integer[128]; int flag = 0; int result = 0; for(int i=0;i&lt;128;i++)&#123; char_map[i] = 0; &#125; for (int i=0;i&lt;s.length();i++)&#123; char_map[s.charAt(i)]++; &#125; for(int i=0;i&lt;128;i++)&#123; if (char_map[i]%2==0)&#123; result += char_map[i]; &#125; else&#123; result += char_map[i]-1; flag = 1; &#125; &#125; return result+flag; &#125;&#125; 2. LeetCode 290 单词规律题目描述给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 示例1: 输入: pattern = “abba”, str = “dog cat cat dog”输出: true示例 2: 输入:pattern = “abba”, str = “dog cat cat fish”输出: false示例 3: 输入: pattern = “aaaa”, str = “dog cat cat dog”输出: false示例 4: 输入: pattern = “abba”, str = “dog dog dog dog”输出: false 解决123456789101112131415161718192021222324252627282930313233class Solution &#123; public boolean wordPattern(String pattern, String s) &#123; int pos = 0; Map&lt;String,Integer&gt; word_map = new HashMap&lt;&gt;(); int[] used = new int[128]; for (int c:used)&#123; c = 0; &#125; String[] words = s.split(&quot; &quot;); for (String word: words)&#123; if (pos == pattern.length()) return false; // 该单词还未出现过 if (word_map.get(word)==null)&#123; // 改单词未出现过，但在used里出现了其pattern对应值，故匹配错误 if (used[pattern.charAt(pos)]==1) return false; // 单词第一次出现，加入map 和标记 used word_map.put(word,(int)pattern.charAt(pos)); used[pattern.charAt(pos)] = 1; &#125; else&#123; // 该单词出现过但不匹配 if (word_map.get(word)!=pattern.charAt(pos)) return false; &#125; pos++; &#125; if (pos!=pattern.length()) return false; return true; &#125;&#125; 3. LeetCode 49 字母异位词分组题目描述给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 示例: 输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]输出:[ [“ate”,”eat”,”tea”], [“nat”,”tan”], [“bat”]]说明： 所有输入均为小写字母。不考虑答案输出的顺序。 解决123456789101112131415161718192021222324class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; Map&lt;String,List&lt;String&gt;&gt; anagram = new HashMap&lt;&gt;(); List&lt;List&lt;String&gt;&gt; result = new ArrayList&lt;&gt;(); for (String str: strs)&#123; String strTemp = str; // 排序 char[] chars = str.toCharArray(); Arrays.sort(chars); strTemp = String.valueOf(chars); if (anagram.get(strTemp)==null)&#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); anagram.put(strTemp,list); &#125; anagram.get(strTemp).add(str); &#125; for (List&lt;String&gt; l: anagram.values())&#123; result.add(l); &#125; return result; &#125;&#125; 4. LeetCode 3 无重复字符的最长子串题目描述给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。示例 2: 输入: s = “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。示例 3: 输入: s = “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。示例 4: 输入: s = “”输出: 0 解决1234567891011121314151617181920212223242526272829303132class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; int begin = 0; int result = 0; String word = &quot;&quot;; int[] char_map = new int[128]; for (int c : char_map)&#123; c = 0; &#125; char[] chars = s.toCharArray(); for (int i=0;i&lt;chars.length;i++)&#123; char_map[chars[i]]++; if (char_map[chars[i]]==1)&#123; word += chars[i]; if (result&lt;word.length())&#123; result = word.length(); &#125; &#125; else&#123; while(char_map[chars[i]]&gt;1)&#123; char_map[chars[begin]]--; begin++; &#125; word = &quot;&quot;; for (int j=begin;j&lt;=i;j++)&#123; word += chars[j]; &#125; &#125; &#125; return result; &#125;&#125; 5. LeetCode 187 重复的DNA序列题目描述所有 DNA 都由一系列缩写为 ‘A’，’C’，’G’ 和 ‘T’ 的核苷酸组成，例如：”ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。 编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。 示例 1： 输入：s = “AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT”输出：[“AAAAACCCCC”,”CCCCCAAAAA”]示例 2： 输入：s = “AAAAAAAAAAAAA”输出：[“AAAAAAAAAA”] 提示： 0 &lt;= s.length &lt;= 105s[i] 为 ‘A’、’C’、’G’ 或 ‘T’ 解决123456789101112131415161718class Solution &#123; public List&lt;String&gt; findRepeatedDnaSequences(String s) &#123; Map&lt;String,Integer&gt; word_map = new HashMap&lt;&gt;(); List&lt;String&gt; result = new ArrayList&lt;&gt;(); for (int i=0;i&lt;s.length()-9;i++)&#123; String word = s.substring(i,i+10); if (word_map.get(word) != null) word_map.put(word,word_map.get(word)+1); else word_map.put(word,1); &#125; for (Map.Entry&lt;String,Integer&gt; entry:word_map.entrySet())&#123; if (entry.getValue()&gt;1) result.add(entry.getKey()); &#125; return result; &#125;&#125; 6. LeetCode 76 最小覆盖子串题目描述给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 “” 。 注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1： 输入：s = “ADOBECODEBANC”, t = “ABC”输出：”BANC”示例 2： 输入：s = “a”, t = “a”输出：”a” 解决12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution &#123; private boolean is_window_ok(int[] map_s,int map_t[],List&lt;Integer&gt; list_t)&#123; for (int i=0;i&lt;list_t.size();i++)&#123; if (map_s[list_t.get(i)] &lt; map_t[list_t.get(i)])&#123; return false; &#125; &#125; return true; &#125; public String minWindow(String s, String t) &#123; final int MAX_ARRAY_LEN = 128; int[] map_t = new int[MAX_ARRAY_LEN]; int[] map_s = new int[MAX_ARRAY_LEN]; List&lt;Integer&gt; list_t = new ArrayList&lt;&gt;(); for (int i=0;i&lt;t.length();i++)&#123; map_t[t.charAt(i)]++; &#125; for (int i=0;i&lt;MAX_ARRAY_LEN;i++)&#123; if (map_t[i]&gt;0) list_t.add(i); &#125; int window_begin = 0; String result = &quot;&quot;; for (int i=0;i&lt;s.length();i++)&#123; map_s[s.charAt(i)]++; while(window_begin &lt; i)&#123; char begin_ch = s.charAt(window_begin); if (map_t[begin_ch]==0)&#123; window_begin++; &#125; else if(map_s[begin_ch]&gt; map_t[begin_ch])&#123; map_s[begin_ch]--; window_begin++; &#125; else&#123; break; &#125; &#125; if (is_window_ok(map_s,map_t,list_t))&#123; int new_window_len = i - window_begin + 1; if (result.equals(&quot;&quot;)||result.length()&gt;new_window_len)&#123; result = s.substring(window_begin,i+1); &#125; &#125; &#125; return result; &#125;&#125; ps: 小象学院教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"二叉树与图算法例子【总】","slug":"二叉树与图","date":"2020-10-04T07:28:19.000Z","updated":"2020-10-04T07:28:19.000Z","comments":true,"path":"2020/10/04/二叉树与图/","link":"","permalink":"https://jinondo.github.io/2020/10/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%9B%BE/","excerpt":"","text":"本文章记录二叉树与图的一些 LeetCode 题目，是我学习b站小象学院视频教程所做笔记，文末注明教程出处。侵删 ¯\\_( ͡° ͜ʖ ͡°)_/¯ LeetCode [113] 路径总和Ⅱ题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。 说明: 叶子节点是指没有子节点的节点。 示例给定如下二叉树，以及目标和 sum = 22， 5 / \\ 4 8 / / \\ 11 13 4 / \\ / \\ 7 2 5 1 返回: [ [5,4,11,2], [5,8,4,5]] 算法思想其实就很简单的二叉树搜索吧，把先序的深度遍历结点记录到一个栈里（直接用c++的vector实现即可），然后加以判断是否符合条件，递归完在出栈。 代码1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; path; int path_value = 0; preorder(root,path_value,sum,path,result); return result; &#125;private: void preorder(TreeNode *node,int &amp;path_value,int sum, vector&lt;int&gt; &amp;path, vector&lt;vector&lt;int&gt;&gt; &amp;result)&#123; if(!node)&#123; return; &#125; path_value += node-&gt;val; path.push_back(node-&gt;val); if(!node-&gt;left &amp;&amp; !node-&gt;right &amp;&amp; path_value==sum)&#123; result.push_back(path); &#125; preorder(node-&gt;left,path_value,sum,path,result); preorder(node-&gt;right,path_value,sum,path,result); path_value -= node-&gt;val; path.pop_back(); &#125;&#125;; LeetCode [236] 二叉树的最近公共祖先问题描述给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 算法思路先去找到以这两个节点为末尾的从根节点开始的两条路径，然后判断路经长短，两条路径同时向后遍历，找到长路径和短路径相同的最后面的那个节点，即为所求 算法代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; vector&lt;TreeNode*&gt; path; vector&lt;TreeNode*&gt; node_p_path; vector&lt;TreeNode*&gt; node_q_path; int finish = 0; preorder(root,p,path,node_p_path,finish); // 找到第一个节点 p 的路径 path.clear(); // 将临时栈置空 finish=0; preorder(root,q,path,node_q_path,finish); // 找到第二个节点 p 的路径 // 根据两条路径长短判断和一致判断找出最后的公共节点，即公共祖先 int path_len=0; if(node_p_path.size() &lt; node_q_path.size())&#123; path_len = node_p_path.size(); &#125; else&#123; path_len = node_q_path.size(); &#125; TreeNode *result = 0; for(int i=0;i&lt;path_len;i++)&#123; if(node_p_path[i] == node_q_path[i])&#123; result = node_p_path[i]; &#125; &#125; return result; &#125;private: void preorder(TreeNode *node,TreeNode *search,vector&lt;TreeNode*&gt; &amp;path, vector&lt;TreeNode*&gt; &amp;result,int &amp;finish)&#123; if(!node || finish)&#123; // 当node为空或已找到指定节点时返回 return; &#125; path.push_back(node); // 将节点压入栈 if(node == search)&#123; finish=1; // 找到节点后更新finish的值 result=path; // 将当前path储存起来 &#125; preorder(node-&gt;left,search,path,result,finish); preorder(node-&gt;right,search,path,result,finish); path.pop_back(); &#125;&#125;; LeetCode [114] 二叉树展开为链表问题描述给定一个二叉树，原地将它展开为一个单链表。 例如，给定二叉树 1 / \\ 2 5 / \\ \\ 3 4 6 将其展开为： 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 算法思路图片来自小象学院教程 算法代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: void flatten(TreeNode* root) &#123; TreeNode *last = NULL; preorder(root,last); &#125;private: void preorder(TreeNode *node,TreeNode *&amp;last)&#123; if(!node)&#123; return; &#125; if(!node-&gt;left &amp;&amp; !node-&gt;right)&#123; last = node; return; &#125; TreeNode *left = node-&gt;left; TreeNode *right = node-&gt;right; TreeNode *left_last = NULL; TreeNode *right_last = NULL; // 处理左子树，使其为拉直的链表 if(left)&#123; preorder(left,left_last); node-&gt;left = NULL; node-&gt;right = left; last = left_last; &#125; // 处理右子树，使其为拉直的链表，并连接左右子树的链表 if(right)&#123; preorder(right,right_last); if(left_last)&#123; left_last-&gt;right = right; &#125; last = right_last; &#125; &#125;&#125;; LeetCode [199] 二叉树的右视图题目描述给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例输入: [1,2,3,null,5,null,4]输出: [1, 3, 4]解释: 1 &lt;--- / \\ 2 3 &lt;--- \\ \\ 5 4 &lt;--- 算法思想运用层次遍历二叉树，记录每层最后一个结点 12345678层次遍历大致算法： 设置队列Q 将根节点入队列Q while(Q不为空)&#123; 去除队列头部结点node 对node访问 将node的左、右孩子入队列 &#125; 算法代码1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;int&gt; rightSideView(TreeNode* root) &#123; vector&lt;int&gt; view; queue&lt;pair&lt;TreeNode *,int&gt;&gt; Q; if(root)&#123; Q.push(make_pair(root,0)); // 将根节点结合层数0入队列 &#125; while(!Q.empty())&#123; TreeNode *node = Q.front().first; int depth = Q.front().second; Q.pop(); if(view.size()==depth)&#123; view.push_back(node-&gt;val); &#125; else&#123; view[depth] = node-&gt;val; &#125; if(node-&gt;left)&#123; Q.push(make_pair(node-&gt;left,depth+1)); &#125; if(node-&gt;right)&#123; Q.push(make_pair(node-&gt;right,depth+1)); &#125; &#125; return view; &#125;&#125;; LeetCode [207] 课程表题目描述你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse-1 。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0,1] 给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？ 示例示例 1: 输入: 2, [[1,0]]输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。 示例 2: 输入: 2, [[1,0],[0,1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。 深度遍历搜索算法思路用图操作写代码，用邻接表储存一个图，表示其依赖关系，用图的深度遍历方法。判断节点在深度搜索过程中有没有再度遇到同个节点（注意是在搜索过程中，而不是搜索完成回溯时）。如果再度遇见同一节点则该图有环，课程不能进行。 算法代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546struct GraphNode&#123; int label; vector&lt;GraphNode *&gt; neighbors; GraphNode(int x): label(x) &#123;&#125;;&#125;;class Solution &#123;public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; vector&lt;GraphNode *&gt; graph; // 邻接表 vector&lt;int&gt; visit; for(int i=0;i&lt;numCourses;i++)&#123; graph.push_back(new GraphNode(i)); visit.push_back(-1); &#125; for(int i=0;i&lt;prerequisites.size();i++)&#123; GraphNode *begin = graph[prerequisites[i][1]]; GraphNode *end = graph[prerequisites[i][0]]; begin-&gt;neighbors.push_back(end); &#125; for(int i=0;i&lt;graph.size();i++)&#123; if(visit[i] == -1 &amp;&amp; !DFS_graph(graph[i],visit))&#123; return false; &#125; &#125; for(int i=0;i&lt;numCourses;i++)&#123; delete graph[i]; &#125; return true; &#125;private: bool DFS_graph(GraphNode *node,vector&lt;int&gt; &amp;visit)&#123; visit[node-&gt;label] = 0; for(int i=0;i&lt;node-&gt;neighbors.size();i++)&#123; if(visit[node-&gt;neighbors[i]-&gt;label] == -1)&#123; if(DFS_graph(node-&gt;neighbors[i],visit)==0)&#123; return false; &#125; &#125; else if(visit[node-&gt;neighbors[i]-&gt;label]==0)&#123; return false; &#125; &#125; visit[node-&gt;label] = 1; return true; &#125;&#125;; 拓扑排序（宽度优先搜索）算法思路创建一个队列，初始把入度为0的点加入队列，当队列不为空时执行： 弹出队头，让队头指向的那个节点的入度减一，且如果该节点入度为0则加入队列，进行循环。直到队列为空时，如果依然有点的入度不为0，则该图有环！课程无法进行 算法代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct GraphNode&#123; int label; vector&lt;GraphNode *&gt; neighbors; GraphNode(int x): label(x) &#123;&#125;;&#125;;class Solution &#123;public: bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; vector&lt;GraphNode*&gt; graph; // 邻接表 vector&lt;int&gt; degree; // 储存入度 for(int i=0;i&lt;numCourses;i++)&#123; degree.push_back(0); graph.push_back(new GraphNode(i)); &#125; for(int i=0;i&lt;prerequisites.size();i++)&#123; GraphNode *begin = graph[prerequisites[i][1]]; GraphNode *end = graph[prerequisites[i][0]]; begin-&gt;neighbors.push_back(end); degree[prerequisites[i][0]]++; &#125; queue&lt;GraphNode*&gt; Q; // 创建队列 for(int i=0;i&lt;numCourses;i++)&#123; if(degree[i]==0)&#123; Q.push(graph[i]); &#125; &#125; while(!Q.empty())&#123; GraphNode *node = Q.front(); Q.pop(); for(int i=0;i&lt;node-&gt;neighbors.size();i++)&#123; degree[node-&gt;neighbors[i]-&gt;label]--; if(degree[node-&gt;neighbors[i]-&gt;label]==0)&#123; Q.push(node-&gt;neighbors[i]); &#125; &#125; &#125; for(int i=0;i&lt;graph.size();i++)&#123; delete graph[i]; &#125; for(int i=0;i&lt;graph.size();i++)&#123; if(degree[i])&#123; // 如果有入度不为0的则代表课程不能继续进行 return false; &#125; &#125; return true; &#125;&#125;; ps: 小象学院教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"递归-回溯-分治算法例子【总】","slug":"递归-回溯-分治","date":"2020-09-26T12:23:35.000Z","updated":"2020-09-26T12:23:35.000Z","comments":true,"path":"2020/09/26/递归-回溯-分治/","link":"","permalink":"https://jinondo.github.io/2020/09/26/%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF-%E5%88%86%E6%B2%BB/","excerpt":"","text":"本文章记录递归-回溯-分治的一些 LeetCode 题目，是我学习b站小象学院视频教程所做笔记，文末注明教程出处。侵删 ¯\\_( ͡° ͜ʖ ͡°)_/¯ LeetCode [78] 子集问题描述给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例输入: nums = [1,2,3]输出:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] 递归与回溯方法算法思路图片来自小象学院教程 算法代码12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; item; result.push_back(item); // 加入空集 generate(0,nums,item,result); // 调用函数 return result; &#125;private: void generate(int i,vector&lt;int&gt;&amp; nums,vector&lt;int&gt; &amp;item,vector&lt;vector&lt;int&gt;&gt;&amp; result) &#123; if(i&gt;=nums.size())&#123; // 递归结束的条件 return; &#125; item.push_back(nums[i]); result.push_back(item); generate(i+1,nums,item,result); // 第一次递归调用 item.pop_back(); generate(i+1,nums,item,result); // 第二次递归调用 &#125;&#125;; 位运算方法算法思路用2进制数代表子集情况，每一位则可以代表每一个元素。例如A,B,C三个元素，则可以用三位的二进制数表示子集的情况，如001可代表集合中只有A这个元素，111即表示三个元素都存在的子集；用按位与就可以判断每一个二进制码（代表子集的情况）是否含该元素，例如，用001代表A元素，010代表B元素，100代表C元素，则如果有101按位与代表A这个元素的特定码，即001，有：101 &amp; 001 = 1，即 true，则代表其中含有A这个元素，然后将A加入item，这样一来就把二进制码101识别为[A,C]，以此类推。 算法代码1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; int all_set = 1 &lt;&lt; nums.size(); // 子集数量 2^n for(int i=0;i&lt;all_set;i++)&#123; // 遍历所有子集 vector&lt;int&gt; item; for(int j=0;j&lt;nums.size();j++)&#123; if(i &amp; (1&lt;&lt;j))&#123; item.push_back(nums[j]); &#125; // 整数 i 代表从0至2^n-1这2^n个集合 // (1&lt;&lt;j)为构造nums数组的第j个元素的特定二进制码 // 若 i &amp; (1&lt;&lt;j) 为真则 nums[i] 加入item &#125; result.push_back(item); &#125; return result; &#125;&#125;; LeetCode [90] 子集Ⅱ题目描述给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 说明：解集不能包含重复的子集。 示例输入: [1,2,2]输出:[ [2], [1], [1,2,2], [2,2], [1,2], []] 算法思想在上文第一道题的递归算法思想上，要使得有不重复的子集，例如[1,2,1]和[1,1,2]也是属于重复情况。第一种重复情况是顺序一致的两个子集，另一种重复情况是顺序不一致的两个子集。故在前文递归算法基础上，只要对sums先进性排序，就能保证只有顺序一致的子集重复的情况，这时便可以用set集合进行查重去重操作。 算法代码123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; subsetsWithDup(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; item; set&lt;vector&lt;int&gt;&gt; res_set; // 用于去重的集合 set sort(nums.begin(),nums.end()); // 先进行排序，保证由于含有相同元素的集合完全一致能被set识别 result.push_back(item); // 加入空集 generate(0,nums,item,result,res_set); // 调用函数 return result; &#125;private: void generate(int i,vector&lt;int&gt;&amp; nums,vector&lt;int&gt; &amp;item,vector&lt;vector&lt;int&gt;&gt;&amp; result,set&lt;vector&lt;int&gt;&gt; &amp;res_set) &#123; if(i&gt;=nums.size())&#123; // 递归结束的条件 return; &#125; item.push_back(nums[i]); if(res_set.find(item) == res_set.end())&#123; result.push_back(item); res_set.insert(item); &#125; generate(i+1,nums,item,result,res_set); // 第一次递归调用 item.pop_back(); generate(i+1,nums,item,result,res_set); // 第二次递归调用 &#125;&#125;; LeetCode [40] 组合总和Ⅱ题目描述给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 candidates 中的每个数字在每个组合中只能使用一次。 说明： 所有数字（包括目标数）都是正整数。 解集不能包含重复的组合。 示例示例 1:输入: candidates = [10,1,2,7,6,1,5], target = 8,所求解集为:[ [1, 7], [1, 2, 5], [2, 6], [1, 1, 6]] 示例 2:输入: candidates = [2,5,2,1,2], target = 5,所求解集为:[ [1,2,2], [5]] 算法思路也是在[90]那道题上略微修改，运用剪枝操作，遇到子集构造过程中子集元素和已大于target目标时，提前回溯，大大提高算法效率！ 算法代码12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combinationSum2(vector&lt;int&gt;&amp; candidates, int target) &#123; vector&lt;vector&lt;int&gt;&gt; result; vector&lt;int&gt; item; set&lt;vector&lt;int&gt;&gt; res_set; // 用于去重的集合 set sort(candidates.begin(),candidates.end()); // 先进行排序，保证由于含有相同元素的集合完全一致能被set识别 generate(0,candidates,item,result,res_set,0,target); // 调用函数 return result; &#125;private: void generate(int i,vector&lt;int&gt;&amp; nums,vector&lt;int&gt; &amp;item,vector&lt;vector&lt;int&gt;&gt;&amp; result,set&lt;vector&lt;int&gt;&gt; &amp;res_set,int sum,int target) &#123; if(i&gt;=nums.size() || sum&gt;target)&#123; // 递归结束的条件 return; &#125; sum += nums[i]; item.push_back(nums[i]); if(target==sum &amp;&amp; res_set.find(item) == res_set.end())&#123; result.push_back(item); res_set.insert(item); &#125; generate(i+1,nums,item,result,res_set,sum,target); // 第一次递归调用 item.pop_back(); sum -= nums[i]; generate(i+1,nums,item,result,res_set,sum,target); // 第二次递归调用 &#125;&#125;; LeetCode [20] 括号生成题目描述数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例输入：n = 3输出：[ “((()))”, “(()())”, “(())()”, “()(())”, “()()()” ] 算法思路 递归，每次走两条路，一条路为添加左括号，一条路为添加右括号 考虑上左右括号匹配，必须要有左括号才能有右括号，即每次左括号在n范围内可以直接加入，但右括号要判断一下右括号的个数必须小于左括号的个数才能加入。 算法代码123456789101112131415161718192021222324class Solution &#123;public: vector&lt;string&gt; generateParenthesis(int n) &#123; vector&lt;string&gt; result; generate(&quot;&quot;,n,n,result); return result; &#125;private: void generate(string item,int left,int right,vector&lt;string&gt; &amp;result)&#123; // item 为表示一种组合的 string // left 为当前还能放置左括号的数量 // right 为当前还能放置的有括号的数量 if(left==0 &amp;&amp; right==0)&#123; result.push_back(item); return ; &#125; if(left &gt; 0)&#123; generate(item+&#x27;(&#x27;,left-1,right,result); &#125; if(left&lt;right)&#123; generate(item+&#x27;)&#x27;,left,right-1,result); &#125; &#125;&#125;; LeetCode [51] N皇后问题描述n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。 每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。 示例输入：4输出：[ [“.Q..”, // 解法 1 “…Q”, “Q…”, “..Q.”], [“..Q.”, // 解法 2 “Q…”, “…Q”, “.Q..”]]解释: 4 皇后问题存在两个不同的解法。 算法思路 先写一个函数用来计算当棋盘中（x,y）被放置皇后后，整个棋盘会剩下多少个可以放另外的皇后而不被攻击的格子，用一个矩阵表示，初始矩阵为 0，后计算出会被攻击的格子置为 1. 利用回溯算法，每次考虑一行的皇后放置，按列遍历看哪个格子为安全格子，便进行放置，如果到某种情况下皇后没有格子可放了就回溯。直接上图吧 图片来自小象学院教程 算法代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123; vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; location; vector&lt;vector&lt;int&gt;&gt; mark; for(int i=0;i&lt;n;i++)&#123; mark.push_back((vector&lt;int&gt;())); for(int j=0;j&lt;n;j++)&#123; mark[i].push_back(0); &#125; location.push_back(&quot;&quot;); location[i].append(n,&#x27;.&#x27;); &#125; generate(0,n,location,result,mark); return result; &#125;private: // 放置一个皇后 mark 矩阵相应改变的函数 void put_down_the_queen(int x,int y,vector&lt;vector&lt;int&gt;&gt; &amp;mark)&#123; static const int dx[] = &#123;-1,1,0,0,-1,-1,1,1&#125;; static const int dy[] = &#123;0,0,-1,1,-1,1,-1,1&#125;; mark[x][y] = 1; for(int i=1;i&lt;mark.size();i++)&#123; for(int j=0;j&lt;8;j++)&#123; int new_x = x + i*dx[j]; int new_y = y + i*dy[j]; if(new_x&gt;=0 &amp;&amp; new_x&lt;mark.size() &amp;&amp; new_y&gt;=0 &amp;&amp; new_y&lt;mark.size())&#123; mark[new_x][new_y] = 1; &#125; &#125; &#125; &#125; // 求各个方案的递归函数 void generate(int k,int n,vector&lt;string&gt; &amp;location,vector&lt;vector&lt;string&gt;&gt; &amp;result,vector&lt;vector&lt;int&gt;&gt; &amp;mark)&#123; if(k==n)&#123; result.push_back(location); return; &#125; for(int i=0;i&lt;n;i++)&#123; if(mark[k][i] == 0)&#123; vector&lt;vector&lt;int&gt;&gt; tmp_mark = mark; location[k][i] = &#x27;Q&#x27;; put_down_the_queen(k,i,mark); generate(k+1,n,location,result,mark); mark = tmp_mark; location[k][i] = &#x27;.&#x27;; &#125; &#125; &#125;&#125;; LeetCode [315] 计算右侧小于当前元素的个数（求逆序数）题目描述给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts 有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 示例输入：nums = [5,2,6,1]输出：[2,1,1,0]解释：5 的右侧有 2 个更小的元素 (2 和 1)2 的右侧仅有 1 个更小的元素 (1)6 的右侧有 1 个更小的元素 (1)1 的右侧有 0 个更小的元素 算法思路分治法的归并排序这道题的重要思路是由归并排序扩展开的，先补充一下归并排序 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;// 把两个已排序的数组有序合成void merge_sort_two_vec(vector&lt;int&gt;&amp; sub_vec1, vector&lt;int&gt;&amp; sub_vec2, vector&lt;int&gt;&amp; vec) &#123; int i = 0; int j = 0; while (i &lt; sub_vec1.size() &amp;&amp; j &lt; sub_vec2.size()) &#123; if (sub_vec1[i] &lt;= sub_vec2[j]) &#123; vec.push_back(sub_vec1[i]); i++; &#125; else &#123; vec.push_back(sub_vec2[j]); j++; &#125; &#125; for (; i &lt; sub_vec1.size(); i++) &#123; vec.push_back(sub_vec1[i]); &#125; for (; j &lt; sub_vec2.size(); j++) &#123; vec.push_back(sub_vec2[j]); &#125;&#125;// 归并排序void merge_sort(vector&lt;int&gt;&amp; vec) &#123; // 只有一个数则直接返回 // 即在递归中把问题分解到足够小时 if (vec.size() &lt; 2) &#123; return; &#125; int mid = vec.size() / 2; vector&lt;int&gt; sub_vec1; vector&lt;int&gt; sub_vec2; for (int i = 0; i &lt; mid; i++) &#123; sub_vec1.push_back(vec[i]); &#125; for (int i = mid; i &lt; vec.size(); i++) &#123; sub_vec2.push_back(vec[i]); &#125; merge_sort(sub_vec1); merge_sort(sub_vec2); vec.clear(); merge_sort_two_vec(sub_vec1, sub_vec2, vec);&#125;int main()&#123; int nums[] = &#123; -3,9,4,10,23,5,11,-6,21,-7 &#125;; vector&lt;int&gt; vec; for (int i = 0; i &lt; 10; i++) &#123; vec.push_back(nums[i]); &#125; merge_sort(vec); for (int i = 0; i &lt; 10; i++) &#123; cout &lt;&lt; vec[i] &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 算法思路每次有两个已经排序好的两个数组，按上面归并排序第一个函数（把两个已排序的数组有序合成）的算法加入新的数组，而其中第一个数组中的count即为j的值（i为第一个数组的索引，j为第二个数组的索引）。 算法代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class Solution &#123;public: vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; vector&lt;pair&lt;int, int&gt;&gt; vec; vector&lt;int&gt; count; for (int i = 0; i &lt; nums.size(); i++) &#123; vec.push_back(make_pair(nums[i], i)); count.push_back(0); // 将nums[i]与 i 绑定为 pair &#125; merge_sort(vec, count); return count; &#125;private: void merge_sort_two_vec( vector&lt;pair&lt;int, int&gt;&gt;&amp; sub_vec1, vector&lt;pair&lt;int, int&gt;&gt;&amp; sub_vec2, vector&lt;pair&lt;int, int&gt;&gt;&amp; vec, vector&lt;int&gt;&amp; count ) &#123; int i = 0; int j = 0; while (i &lt; sub_vec1.size() &amp;&amp; j &lt; sub_vec2.size()) &#123; if (sub_vec1[i].first &lt;= sub_vec2[j].first) &#123; // 比较用pair的第一个元素 count[sub_vec1[i].second] += j; // 第二个元素缩影用来记录count vec.push_back(sub_vec1[i]); i++; &#125; else &#123; vec.push_back(sub_vec2[j]); j++; &#125; &#125; for (; i &lt; sub_vec1.size(); i++) &#123; count[sub_vec1[i].second] += j; vec.push_back(sub_vec1[i]); &#125; for (; j &lt; sub_vec2.size(); j++) &#123; vec.push_back(sub_vec2[j]); &#125; &#125; void merge_sort(vector&lt;pair&lt;int, int&gt;&gt;&amp; vec, vector&lt;int&gt;&amp; count) &#123; // 只有一个数则直接返回 // 即在递归中把问题分解到足够小时 if (vec.size() &lt; 2) &#123; return; &#125; int mid = vec.size() / 2; vector&lt;pair&lt;int, int&gt;&gt; sub_vec1; vector&lt;pair&lt;int, int&gt;&gt; sub_vec2; for (int i = 0; i &lt; mid; i++) &#123; sub_vec1.push_back(vec[i]); &#125; for (int i = mid; i &lt; vec.size(); i++) &#123; sub_vec2.push_back(vec[i]); &#125; merge_sort(sub_vec1,count); merge_sort(sub_vec2, count); vec.clear(); merge_sort_two_vec(sub_vec1, sub_vec2, vec, count); &#125;&#125;; ps: 小象学院教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"贪心法算法例子【总】","slug":"贪心法算法例子","date":"2020-09-17T12:35:53.000Z","updated":"2020-09-17T12:35:53.000Z","comments":true,"path":"2020/09/17/贪心法算法例子/","link":"","permalink":"https://jinondo.github.io/2020/09/17/%E8%B4%AA%E5%BF%83%E6%B3%95%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%90/","excerpt":"","text":"本文章记录贪心法的一些 LeetCode 题目，是我学习b站小象学院视频教程所做笔记，文末注明教程出处。侵删 ¯\\_( ͡° ͜ʖ ͡°)_/¯ LeetCode [455] 分发饼干问题描述假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例输入: [1,2,3], [1,1] 输出: 1 解释:你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。 解决思路先把输入的两组数据排序，然后根据每一个饼干从小到大去选择对应可以被满足的孩子 算法代码12345678910111213141516class Solution &#123;public: int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) &#123; std::sort(g.begin(),g.end()); std:sort(s.begin(),s.end()); int child = 0; int cookie = 0; while(child&lt;g.size() &amp;&amp; cookie&lt;s.size())&#123; if(g[child]&lt;=s[cookie])&#123; child++; &#125; cookie++; &#125; return child; &#125;&#125;; LeetCode [376] 摆动序列题目描述如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 示例示例 1:输入: [1,7,4,9,2,5]输出: 6解释: 整个序列均为摆动序列。 示例 2:输入: [1,17,5,10,13,15,10,5,16,8]输出: 7解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 解题思路使用一个状态机，有三种状态 开始状态 BEGIN：如果下一个数字比当前的数字要大，则转入上升状态UP；如果下一个数字比当前的数字要小，则转入下降状态DOWN； 上升状态 UP：如果下一个数字比当前数字更大，则无事发生；如果下一个数字比当前数字小（即符合摆动序列），令max_length++，即长度加一，然后转入下降状态。 下降状态 DOWN：如果下一个数字比当前数字更小，则无数发生；如果下一个数字比当前数字大，符合摆动序列，则令max_length++，长度加一，然后转入上升状态。 在状态机运行过程中吗，如果有持续上升，或持续下降的情况，则取上升到最大或下降到最小的那个数值，保证后面的数字可以满足摆动序列的概率最大，即涉及到贪心的思想。 套用一个循环遍历，算出最长子序列的长度。 算法代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: int wiggleMaxLength(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()&lt;2)&#123; return nums.size(); // 序列个数小于2则本身就是摇摆序列 &#125; // 设置状态机的三种状态 static const int BEGIN= 0; static const int UP = 1; static const int DOWN = 2; int STATE = BEGIN; int max_length = 1; // 先设置最大长度至少为1 // 从第二个元素开始遍历 for(int i=1;i&lt;nums.size();i++) &#123; switch(STATE)&#123; case BEGIN: // 开始状态 if(nums[i-1]&lt;nums[i])&#123; STATE = UP; max_length++; &#125; else if(nums[i-1]&gt;nums[i])&#123; STATE = DOWN; max_length++; &#125; break; case UP: // 数值上升状态 if(nums[i-1]&gt;nums[i])&#123; STATE=DOWN; max_length++; &#125; break; case DOWN: // 数值下降状态 if(nums[i-1]&lt;nums[i])&#123; STATE = UP; max_length++; &#125; break; &#125; &#125; return max_length; &#125;&#125;; LeetCode [402] 移掉 k 位数字题目描述给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。 注意: num 的长度小于 10002 且 ≥ k。 num 不会包含任何前导零。 示例示例 1 : 输入: num = “1432219”, k = 3输出: “1219”解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。 示例 2 : 输入: num = “10200”, k = 1输出: “200”解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。 解题思路题目要求剩下的数字组成的数值最大，故每次要留下较小的数字，从最高位开始，尽量取小的数。即设计一个栈，从第一个元素按顺序加入栈，每次一个数字加入栈要判断该数字大小，如果比栈顶数字大，则直接压入栈，如果比栈顶数字小，则把栈顶出栈，继续判断该值和更新后的栈顶大小。循环直到所有数字都进入栈或者k&lt;=0，如果数字全进入栈了但k依然大于0，则继续将栈做弹出操作直到k=0。 算法代码1234567891011121314151617181920212223242526272829303132class Solution &#123;public: string removeKdigits(string num, int k) &#123; std::vector&lt;int&gt; S; // 用vector作为类似栈结构来使用 std::string result = &quot;&quot;; // 储存最终结果 int number = 0; for(int i=0; i&lt;num.length(); i++)&#123; number = num[i] - &#x27;0&#x27;; // 当栈非空 且 栈顶（这里就是vector最后一个元素，即最后一个数字）大于number 且 k&gt;0（即仍然可以删除数字） while(S.size()!=0 &amp;&amp; S[S.size()-1]&gt;number &amp;&amp; k&gt;0)&#123; S.pop_back(); k--; &#125; if(number!=0 || S.size()!=0)&#123; S.push_back(number); // 将数字压入栈 &#125; &#125; while(S.size()!=0 &amp;&amp; k&gt;0)&#123; // 此时栈不空且还能继续删数字，故继续删至k为0 S.pop_back(); k--; &#125; for(int i=0;i&lt;S.size();i++)&#123; // 储存结果到 result 中 result.append(1,&#x27;0&#x27;+S[i]); &#125; if(result == &quot;&quot;)&#123; result = &quot;0&quot;; &#125; return result; &#125;&#125;; LeetCode [55] 跳跃游戏题目描述定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个位置。 示例示例 1: 输入: [2,3,1,1,4]输出: true解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。 示例 2: 输入: [3,2,1,0,4]输出: false解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。 算法思路先去找出每一个位置作为当前位置时可以跳的最远的位置，程序中即 index[i] = nums[i]+i，使用贪心法思想，则是依次找每一个位置能跳的最远距离 max_index，一次循环更新一次当前能跳的最远距离，直到jump值（遍历到的那个位置）大于max_index, 或者jump已经到达末尾。检查jump如果等于到了末尾则表示可以从位置0到达最后一个位置。 算法代码123456789101112131415161718192021class Solution &#123;public: bool canJump(vector&lt;int&gt;&amp; nums) &#123; std::vector&lt;int&gt; index; // 计算最远可跳至的位置 for(int i=0;i&lt;nums.size();i++)&#123; index.push_back(i+nums[i]); &#125; int jump = 0; int max_index = index[0]; while(jump&lt;index.size() &amp;&amp; jump&lt;=max_index)&#123; if(max_index&lt;index[jump])&#123; max_index = index[jump]; // 保存可以跳的更远的目标位置 &#125; jump++; &#125; if(jump == index.size())&#123; // 若jump到达数组尾部，说明可以到达最后一个位置，返回真 return true; &#125; return false; // 否则返回假 &#125;&#125;; LeetCode [55] 跳跃游戏2题目描述给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例示例:输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 算法思路贪心原理：每次都跳到当前能跳到的最远位置，如果发现该位置不能跳到末尾，则再选择这之前的一个位置，该位置是除了当前位置能跳最远位置的位置。其实思路说起来有点绕，看代码吧。 算法代码123456789101112131415161718192021class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()&lt;2)&#123; // 如果数组小于2则直接返回0 return 0; &#125; int current_max_index = nums[0]; // 当前可到达的最远位置 int pre_max_index = nums[0]; // 遍历各个位置过程中，可达到的最远位置 int jump = 1; for(int i=1;i&lt;nums.size();i++)&#123; if(i&gt;current_max_index)&#123; // 若无法再向前移动移动了，才进行跳跃 jump++; // 更新跳跃次数 current_max_index = pre_max_index; // 更新当前可到达的最远位置 &#125; if(pre_max_index&lt;nums[i]+i)&#123; pre_max_index = nums[i] +i; // 在遍历时如果找到一个能跳更远位置的位置，则更新 pre_max_index &#125; &#125; return jump; &#125;&#125;; LeetCode [452] 用最少数量的箭引爆气球题目描述在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。 一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足 xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。 示例Example: 输入:[[10,16], [2,8], [1,6], [7,12]] 输出:2 解释:对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。 算法思路初始化一支箭，射爆尽量多的气球 算法代码123456789101112131415161718192021222324252627282930bool cmp(const vector&lt;int&gt; &amp;a,const vector&lt;int&gt;&amp;b)&#123; return a[0] &lt; b[0];&#125;class Solution &#123;public: int findMinArrowShots(vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; if(points.size()==0)&#123; return 0; &#125; sort(points.begin(),points.end(),cmp); int shoot_num = 1; int shoot_begin = points[0][0]; int shoot_end = points[0][1]; for(int i=1;i&lt;points.size();i++)&#123; if(points[i][0] &lt;= shoot_end)&#123; shoot_begin = points[i][0]; if(shoot_end &gt; points[i][1])&#123; shoot_end = points[i][1]; &#125; &#125; else&#123; shoot_num++; shoot_begin = points[i][0]; shoot_end = points[i][1]; &#125; &#125; return shoot_num; &#125;&#125;; poj [2431] 最优加油方法题目描述A group of cows grabbed a truck and ventured on an expedition deep into the jungle. Being rather poor drivers, the cows unfortunately managed to run over a rock and puncture the truck’s fuel tank. The truck now leaks one unit of fuel every unit of distance it travels. To repair the truck, the cows need to drive to the nearest town (no more than 1,000,000 units distant) down a long, winding road. On this road, between the town and the current location of the truck, there are N (1 &lt;= N &lt;= 10,000) fuel stops where the cows can stop to acquire additional fuel (1..100 units at each stop). The jungle is a dangerous place for humans and is especially dangerous for cows. Therefore, the cows want to make the minimum possible number of stops for fuel on the way to the town. Fortunately, the capacity of the fuel tank on their truck is so large that there is effectively no limit to the amount of fuel it can hold. The truck is currently L units away from the town and has P units of fuel (1 &lt;= P &lt;= 1,000,000). Determine the minimum number of stops needed to reach the town, or if the cows cannot reach the town at all. 中文翻译：一群牛抢了一辆卡车，冒险进入丛林深处探险。由于牛是相当糟糕的司机，不幸的是它们撞到了一块石头，并刺穿了卡车的油箱。现在，卡车每行驶一单位距离就会泄漏一单位燃料。 为了修理卡车，奶牛需要沿着一条长长的蜿蜒的公路，驱车到最近的城镇(距离不超过100万单位)。在这条道路上，在城镇和卡车的当前位置之间，有N (1 &lt;= N &lt;= 10,000)燃料站，奶牛可以在那里停下来获取额外的燃料(1..每站100个)。 丛林对人类来说是个危险的地方，对牛来说尤其危险。因此，奶牛们希望在去镇上的路上尽可能少地停下来加油。幸运的是，他们卡车的油箱容量是如此之大，以至于实际上没有限制它所能容纳的燃料量。卡车目前距离城镇L单位，有P单位的燃料(1 &lt;= P &lt;= 1,000,000)。 确定到达城镇所需的最低停车次数，或者如果奶牛根本无法到达城镇。 示例Sample Input 44 45 211 515 1025 10 Sample Output 2 算法代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;bool cmp(const pair&lt;int, int&gt;&amp; a, const pair&lt;int, int&gt;&amp; b) &#123; return a.first &gt; b.first;&#125;int get_minimum_stop(int L, int P, vector&lt;pair&lt;int, int&gt;&gt; &amp;stop) &#123; priority_queue&lt;int&gt; Q; // 存储有量的最大堆 int result = 0; int dis = 0; stop.push_back(make_pair(0, 0)); sort(stop.begin(), stop.end(), cmp); for (int i = 0; i &lt; stop.size(); i++) &#123; dis = L - stop[i].first; while (!Q.empty() &amp;&amp; P&lt;dis) &#123; P += Q.top(); Q.pop(); result++; &#125; if (Q.empty() &amp;&amp; P &lt; dis) &#123; return -1; &#125; P = P - dis; L = stop[i].first; Q.push(stop[i].second); &#125; return result;&#125;int main() &#123; vector&lt;pair&lt;int, int&gt;&gt; stop; int N; int L; int P; int distance; int fuel; scanf_s(&quot;%d&quot;, &amp;N); for (int i = 0; i &lt; N; i++) &#123; scanf_s(&quot;%d %d&quot;, &amp;distance, &amp;fuel); stop.push_back(make_pair(distance, fuel)); &#125; scanf_s(&quot;%d %d&quot;, &amp;L, &amp;P); printf(&quot;%d\\n&quot;, get_minimum_stop(L, P, stop)); return 0;&#125; ps: 小象学院教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"最大最小堆相关算法","slug":"最大最小堆相关算法","date":"2020-08-10T06:02:21.000Z","updated":"2020-08-10T06:02:21.000Z","comments":true,"path":"2020/08/10/最大最小堆相关算法/","link":"","permalink":"https://jinondo.github.io/2020/08/10/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/","excerpt":"","text":"C++ 的 STL 优先级队列构造最大最小堆的方式 123priority_queue&lt;int&gt; big_heap; // 默认构造最大堆priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; small_heap; // 构造最小堆priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; big_heap2; // 构造最大堆 优先级队列及其函数实例 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;// 以下为测试int main() &#123; priority_queue&lt;int&gt; big_heap; // 默认构造最大堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; small_heap; // 构造最小堆 priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; big_heap2; // 构造最大堆 if (big_heap.empty()) &#123; cout &lt;&lt; &quot;最大堆为空!&quot; &lt;&lt; endl; &#125; int test[] = &#123; 6,10,1,7,99,4,33 &#125;; for (int i = 0; i &lt; 7; i++) &#123; big_heap.push(test[i]); &#125; cout &lt;&lt; &quot;最大堆堆顶，即最大值为 &quot; &lt;&lt; big_heap.top() &lt;&lt; endl; big_heap.push(1000); cout &lt;&lt; &quot;最大堆堆顶，即最大值为 &quot; &lt;&lt; big_heap.top() &lt;&lt; endl; for (int i = 0; i &lt; 3; i++) &#123; big_heap.pop(); &#125; cout &lt;&lt; &quot;最大堆堆顶，即最大值为 &quot; &lt;&lt; big_heap.top() &lt;&lt; endl; cout &lt;&lt; &quot;最大堆的元素个数为：&quot; &lt;&lt; big_heap.size() &lt;&lt; endl; return 0;&#125; 结果： 12345最大堆为空!最大堆堆顶，即最大值为 99最大堆堆顶，即最大值为 1000最大堆堆顶，即最大值为 10最大堆的元素个数为：5 求数组中第K个最大元素 题目：在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 解决思路：维护一个K大小的最小队，堆中元素个数小于K时，新元素直接进入堆；否则，当堆顶元素小于新元素时，弹出堆顶，然后将该新元素加入堆。 例如： [3,2,1,5,6,4] 和 k = 2，由于k=2，开始3和2直接进入最小堆，堆顶为2，大于1，故不用操作，接着2大于5了，5要进去堆反而把2弹出，以此类推最后形成一个两个元素的最小堆，堆顶为5，即为所求第K大的数。道理是：两（k）个数中最小的即为6个数中第2大的。品，你细品！12345678910111213141516class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; Q; for (int i = 0; i &lt; nums.size(); i++) &#123; if (Q.size() &lt; k) Q.push(nums[i]); else if (Q.top() &lt; nums[i]) &#123; Q.pop(); Q.push(nums[i]); &#125; &#125; return Q.top(); &#125;&#125;; 求一组数据的中位数问题求一组数据的中位数，中位数是有序列表中间的数。如果列表长度是偶数，中位数则是中间两个数的平均值。例如，[2,3,4] 的中位数是 3[2,3] 的中位数是 (2 + 3) / 2 = 2.5设计一个支持以下两种操作的数据结构： void addNum(int num) - 从数据流中添加一个整数到数据结构中。 double findMedian() - 返回目前所有元素的中位数。 解决 思路：动态维护一个 最大堆 和一个 最小堆，每个堆各存储一半的数据，条件是最大堆的堆顶比最小堆的堆顶小（或相等，也就是说这样数据就被按照大小分成两半了。如果整个数据集元素个数为奇数，则会有一个堆的元素比另一个堆元素多一个，即那个多元素的堆的堆顶就为中位数；如果元素个数为偶数，则取两个堆顶的元素的平均数则为中位数。 算法主要是在加入新数据时维护最大堆和最小堆，有三种情况： 情况1，目前最大堆和最小堆元素个数一致，则检查：如果新元素小于最大堆堆顶，则加入最大堆；如果新元素大于最小堆堆顶，则加入最小堆。 情况2：最大堆比最小堆多一个元素，则检查：如果新元素比最大堆元素大，则直接加入最小堆即可；否则，如果新元素比最大堆元素小或者相等，要注意了，这时候不能直接加入最大堆（会导致最大堆操作完比最小堆多两个元素），正确应该把最大堆堆顶元素加入最小堆并弹出，再把新元素加入最大堆，这样就保持平衡了，女少口阿。 情况3：最小堆比最大堆多一个元素，与上面思路一致！ 完整代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;queue&gt;using namespace std;class MedianFinder &#123;public: /** initialize your data structure here. */ MedianFinder() &#123; &#125; // 数据加入及最大堆和最小堆的维护 void addNum(int num) &#123; if (big_heap.empty()) &#123; big_heap.push(num); return; &#125; // 情况1 if (big_heap.size() == small_heap.size()) &#123; if (num &lt; big_heap.top()) &#123; big_heap.push(num); &#125; else &#123; small_heap.push(num); &#125; &#125; // 情况2 else if (big_heap.size() &gt; small_heap.size()) &#123; if (num &gt; big_heap.top()) small_heap.push(num); else &#123; small_heap.push(big_heap.top()); big_heap.pop(); big_heap.push(num); &#125; &#125; // 情况3 else if (big_heap.size() &lt; small_heap.size()) &#123; if (num &lt; small_heap.top()) big_heap.push(num); else &#123; big_heap.push(small_heap.top()); small_heap.pop(); small_heap.push(num); &#125; &#125; &#125; // 求中位数 double findMedian() &#123; if (big_heap.size() == small_heap.size()) &#123; return (double(big_heap.top()) + small_heap.top()) / 2.0; &#125; else if (big_heap.size() &gt; small_heap.size()) return big_heap.top(); return small_heap.top(); &#125;private: priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; big_heap; // 构造最大堆 priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; small_heap; // 构造最小堆&#125;;// 以下为测试int main() &#123; MedianFinder m; m.addNum(1); m.addNum(2); cout &lt;&lt; m.findMedian() &lt;&lt; endl; m.addNum(3); cout &lt;&lt; m.findMedian() &lt;&lt; endl; return 0;&#125; 结果： 121.52 ps: 小象学院教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2 的笔记LeetCode题号： 215，295","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"基本加减计算器实现","slug":"基本加减计算器实现","date":"2020-08-09T12:22:54.000Z","updated":"2020-08-09T12:22:54.000Z","comments":true,"path":"2020/08/09/基本加减计算器实现/","link":"","permalink":"https://jinondo.github.io/2020/08/09/%E5%9F%BA%E6%9C%AC%E5%8A%A0%E5%87%8F%E8%AE%A1%E7%AE%97%E5%99%A8%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"问题： 实现一个基本的计算器来计算一个简单的字符串表达式的值。 字符串表达式可以包含左括号 ( ，右括号 )，加号 + ，减号 -，非负整数和空格 。 使用用堆栈结构实现：用状态机的实现思路图：———— 图片来自小象学院教程 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// 计算函数void compute(stack&lt;long&gt;&amp; number_stack, stack&lt;char&gt;&amp; operation_stack) &#123; if (number_stack.size() &lt; 2) return; long num2 = number_stack.top(); number_stack.pop(); long num1 = number_stack.top(); number_stack.pop(); if (operation_stack.top() == &#x27;+&#x27;) &#123; number_stack.push(num1 + num2); &#125; else if(operation_stack.top()==&#x27;-&#x27;)&#123; number_stack.push(num1 - num2); &#125; operation_stack.pop();&#125;// 算法写在一个类中class Solution &#123;public: long calculate(string s) &#123; static const int STATE_BEGIN = 0; static const int NUMBER_STATE = 1; static const int OPERATION_STATE = 2; stack&lt;long&gt; number_stack; stack&lt;char&gt; operation_stack; long number = 0; int STATE = STATE_BEGIN; int compute_flag = 0; for (int i = 0; i &lt; s.length(); i++) &#123; if (s[i] == &#x27; &#x27;) continue; // 用菜单实现三种状态 switch (STATE) &#123; case STATE_BEGIN: if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;) &#123; STATE = NUMBER_STATE; &#125; else &#123; STATE = OPERATION_STATE; &#125; i--; break; case NUMBER_STATE: if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;) &#123; // 字符串转数字 number = number * 10 + s[i] - &#x27;0&#x27;; &#125; else &#123; number_stack.push(number); if (compute_flag == 1) compute(number_stack, operation_stack); number = 0; i--; STATE = OPERATION_STATE; &#125; break; case OPERATION_STATE: if (s[i] ==&#x27;+&#x27;||s[i]==&#x27;-&#x27;) &#123; operation_stack.push(s[i]); compute_flag = 1; &#125; else if (s[i] == &#x27;(&#x27;) &#123; STATE = NUMBER_STATE; compute_flag = 0; &#125; else if (s[i] &gt;= &#x27;0&#x27; &amp;&amp; s[i] &lt;= &#x27;9&#x27;) &#123; STATE = NUMBER_STATE; i--; &#125; else if (s[i] == &#x27;)&#x27;) &#123; compute(number_stack, operation_stack); &#125; break; default: break; &#125; &#125; if (number != 0) &#123; number_stack.push(number); compute(number_stack, operation_stack); &#125; if (number == 0 &amp;&amp; number_stack.empty()) &#123; return 0; &#125; return number_stack.top(); &#125;&#125;; 测试： 123456789// 以下为测试int main() &#123; string s = &quot;20+(18-8)-(90-89)&quot;; Solution solve; long result = solve.calculate(s); cout &lt;&lt; &quot;20+(18-8)-(90-89) = &quot; &lt;&lt; result; return 0;&#125; 结果： 120+(18-8)-(90-89) = 29 ps: 小象学院教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2 的笔记LeetCode题号： 224","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"堆栈和队列简单算法题","slug":"堆栈和队列简单算法题","date":"2020-08-08T16:27:00.000Z","updated":"2020-08-08T16:27:00.000Z","comments":true,"path":"2020/08/09/堆栈和队列简单算法题/","link":"","permalink":"https://jinondo.github.io/2020/08/09/%E5%A0%86%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E9%A2%98/","excerpt":"","text":"C++的 STL stack和 STL queue 头文件分别是 &lt;stack&gt; 和 &lt;queue&gt; 注意：使用需要namespace std STL stack基本操作 1234stack&lt;int&gt; S;S.empty();S.push(10);S.pop(); STL queue基本操作 12345queue&lt;int&gt; Q;Q.empty();Q.push(5);Q.pop();Q.front(); 用队列数据结构实现栈使用队列实现栈的下列操作：push(x) – 元素 x 入栈pop() – 移除栈顶元素top() – 获取栈顶元素empty() – 返回栈是否为空 12345678910111213141516171819202122232425262728293031323334353637383940414243// 用队列数据结构实现的stack类class MyStack &#123;public: /** Initialize your data structure here. */ MyStack() &#123; &#125; /** Push element x onto stack. */ void push(int x) &#123; queue&lt;int&gt; temp_queue; temp_queue.push(x); while (!_data.empty()) &#123; // 将数据队列元素在导入临时队列 temp_queue.push(_data.front()); _data.pop(); &#125; while (!temp_queue.empty()) &#123; // 将临时队列元素导入数据队列做保存 _data.push(temp_queue.front()); temp_queue.pop(); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ int pop() &#123; int x = _data.front(); _data.pop(); return x; &#125; /** Get the top element. */ int top() &#123; return _data.front(); &#125; /** Returns whether the stack is empty. */ bool empty() &#123; return _data.empty(); &#125;private: queue&lt;int&gt; _data;&#125;; 用栈数据结构实现队列使用栈实现队列的下列操作：push(x) – 将一个元素放入队列的尾部。pop() – 从队列首部移除元素。peek() – 返回队列首部的元素。empty() – 返回队列是否为空。 思路： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class MyQueue &#123;public: /** Initialize your data structure here. */ MyQueue() &#123; &#125; /** Push element x to the back of queue. */ void push(int x) &#123; stack&lt;int&gt; temp_stack; while (!_data.empty()) &#123; // 将数据栈中的数据导入到临时栈 temp_stack.push(_data.top()); _data.pop(); &#125; // 把要加入的数据加入栈 temp_stack.push(x); while (!temp_stack.empty()) &#123; // 将临时栈中的数据导入到数据栈保存 _data.push(temp_stack.top()); temp_stack.pop(); &#125; &#125; /** Removes the element from in front of queue and returns that element. */ int pop() &#123; int x = _data.top(); _data.pop(); return x; &#125; /** Get the front element. */ int peek() &#123; return _data.top(); &#125; /** Returns whether the queue is empty. */ bool empty() &#123; return _data.empty(); &#125;private: std::stack&lt;int&gt; _data;&#125;; 实现带有最小值的栈结构设计一个能在常数时间内检索到最小元素的栈。由于题目要求要在常数时间复杂度实现，故不用遍历方式找出最小值。根据栈的储存和pop特点，我们并不能用一个变量取储存当前栈的最小值或最大值，你想想，你现在储存的当前栈的最小值刚好是栈顶的元素，下一步对栈做pop弹出操作后，栈的最小值或最大值就发生改变了，故最小值变量并不能实现，所以要用一个最小值栈来储存当前栈的最小值。 1234567891011121314151617181920212223242526272829303132class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; // 先把数据入数据栈 _data.push(x); // 根据数据和最小值栈的栈顶关系来取决要入最小值栈的值 if (!_min.empty() &amp;&amp; x &gt; _min.top()) &#123; x = _min.top(); &#125; _min.push(x); &#125; void pop() &#123; _data.pop(); _min.pop(); // 出栈也要同步最小值栈！ &#125; int top() &#123; return _data.top(); &#125; int getMin() &#123; return _min.top(); &#125;private: std::stack&lt;int&gt; _data; std::stack&lt;int&gt; _min;&#125;; ps: 小象学院教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2 的笔记LeetCode题号： 225，232，155","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"链表深拷贝算法","slug":"链表深拷贝算法","date":"2020-08-07T10:21:22.000Z","updated":"2020-08-07T10:21:22.000Z","comments":true,"path":"2020/08/07/链表深拷贝算法/","link":"","permalink":"https://jinondo.github.io/2020/08/07/%E9%93%BE%E8%A1%A8%E6%B7%B1%E6%8B%B7%E8%B4%9D%E7%AE%97%E6%B3%95/","excerpt":"","text":"问题描述： 复制带随机指针的链表 给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。 要求返回这个链表的 深拷贝。 STL Map的使用123456789101112131415161718int main() &#123; map&lt;Node*, int&gt; node_map; Node a(5); Node b(3); Node c(6); a.next = &amp;b; b.next = &amp;c; a.random = &amp;c; b.random = &amp;a; c.random = &amp;c; node_map[&amp;a] = 1; // 将a的地址映射为1 node_map[&amp;b] = 2; // 将b的地址映射为2 node_map[&amp;c] = 3; // 将c的地址映射为3 cout &lt;&lt; &quot;a的random指针指向：&quot; &lt;&lt; node_map[a.random] &lt;&lt; endl; cout &lt;&lt; &quot;b的random指针指向：&quot; &lt;&lt; node_map[b.random] &lt;&lt; endl; cout &lt;&lt; &quot;c的random指针指向：&quot; &lt;&lt; node_map[c.random] &lt;&lt; endl; return 0;&#125; 结果： 123a的random指针指向：3b的random指针指向：1c的random指针指向：3 解决深拷贝的算法：1234567891011121314151617181920212223242526272829303132// 算法写在一个类里class Solution &#123;public: Node* copyRandomList(Node* head) &#123; map&lt;Node*, int&gt; node_map; // 用vector储存新的链表结点，而vector类似数组有id值便于下面的操作 vector&lt;Node*&gt; node_vec; Node* ptr = head; int i = 0; while (ptr) &#123; node_vec.push_back(new Node(ptr-&gt;val)); node_map[ptr] = i; ptr = ptr-&gt;next; i++; &#125; node_vec.push_back(0); ptr = head; i = 0; while (ptr) &#123; node_vec[i]-&gt;next = node_vec[i + 1]; if (ptr-&gt;random) &#123; int id = node_map[ptr-&gt;random]; // 根据random找出map对应的id node_vec[i]-&gt;random = node_vec[id]; // 根据id在vector里找出该结点 &#125; ptr = ptr-&gt;next; i++; &#125; return node_vec[0]; &#125;&#125;; ps: 教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2 的笔记LeetCode题号： 138","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"多个有序链表的合并","slug":"多个有序链表的合并","date":"2020-08-07T10:21:06.000Z","updated":"2020-08-07T10:21:06.000Z","comments":true,"path":"2020/08/07/多个有序链表的合并/","link":"","permalink":"https://jinondo.github.io/2020/08/07/%E5%A4%9A%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6/","excerpt":"","text":"问题描述:合并 k 个排序链表，返回合并后的排序链表可以有三个办法，在此问题上的基础是进行两个链表的合并，代码如下： 1234567891011121314151617181920212223242526272829303132struct ListNode &#123; int val; ListNode* next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;;// 合并两个有序链表ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode temp_head(0); ListNode* pre = &amp;temp_head; while (l1 &amp;&amp; l2) &#123; if (l1-&gt;val &lt; l2-&gt;val) &#123; pre-&gt;next = l1; l1 = l1-&gt;next; &#125; else &#123; pre-&gt;next = l2; l2 = l2-&gt;next; &#125; pre = pre-&gt;next; &#125; if (l1) &#123; pre-&gt;next = l1; &#125; if (l2) &#123; pre-&gt;next = l2; &#125; return temp_head.next;&#125; 暴力合并直接把第一个链表和第二个链表用两个链表有序合并的方法mergeTwoLists合并为链表new1，再把new和第三个链表合并为new2，以此类推，但此类算法时间复杂度不好，略过……排序后相连（使用vector和sort）方法：把所有节点存入vector然后排序 先演示sort的基本实现：123456789101112131415161718192021bool cmp(const ListNode* a, const ListNode* b) &#123; return a-&gt;val &lt; b-&gt;val;&#125;int main() &#123; ListNode a(3); ListNode b(2); ListNode c(5); ListNode d(0); vector&lt;ListNode*&gt; node_vec; node_vec.push_back(&amp;a); node_vec.push_back(&amp;b); node_vec.push_back(&amp;c); node_vec.push_back(&amp;d); sort(node_vec.begin(), node_vec.end(), cmp); for (int i = 0; i &lt; node_vec.size(); i++) &#123; cout &lt;&lt; node_vec[i]-&gt;val &lt;&lt; endl; &#125; return 0;&#125; 解决问题：12345678910111213141516171819202122232425262728// 算法写在一个类里class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; vector&lt;ListNode*&gt; node_vec; ListNode* head = NULL; for (int i = 0; i &lt; lists.size(); i++) &#123; // 取出每一个链表的结点存入新的vector head = lists[i]; while (head) &#123; node_vec.push_back(head); head = head-&gt;next; &#125; &#125; if (node_vec.size() == 0) &#123; return NULL; &#125; sort(node_vec.begin(), node_vec.end(), cmp); for (int i = 1; i &lt; node_vec.size(); i++) &#123; node_vec[i - 1]-&gt;next = node_vec[i]; //新链表连接 &#125; node_vec[node_vec.size() - 1]-&gt;next = NULL; return node_vec[0]; &#125;&#125;; 分治法递归解决把k个链表每次2分化成最终为两个链表的合并，代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 算法写在一个类里class Solution &#123;public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) &#123; if (lists.size() == 0) return NULL; if(lists.size() == 1) return lists[0]; if (lists.size() == 2) return mergeTwoLists(lists[0], lists[1]); int mid = lists.size() / 2; // 拆分为两个子list vector&lt;ListNode*&gt; sub1_lists; vector&lt;ListNode*&gt; sub2_lists; for (int i = 0; i &lt; mid; i++) &#123; sub1_lists.push_back(lists[i]); &#125; for (int i = mid; i &lt; lists.size(); i++) &#123; sub2_lists.push_back(lists[i]); &#125; ListNode* l1 = mergeKLists(sub1_lists); ListNode* l2 = mergeKLists(sub2_lists); return mergeTwoLists(l1, l2); // 分治处理 &#125;&#125;;// 以下为测试int main() &#123; ListNode a(1); ListNode b(4); ListNode c(6); ListNode d(0); ListNode e(5); ListNode f(7); ListNode g(2); ListNode h(3); a.next = &amp;b; b.next = &amp;c; d.next = &amp;e; e.next = &amp;f; g.next = &amp;h; Solution solve; vector&lt;ListNode*&gt; lists; lists.push_back(&amp;a); lists.push_back(&amp;d); lists.push_back(&amp;g); ListNode* head = solve.mergeKLists(lists); while (head) &#123; cout &lt;&lt; head-&gt;val &lt;&lt; endl; head = head-&gt;next; &#125; return 0;&#125; 结果： 1234567801234567 ps: 小象学院教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2 的笔记LeetCode题号： 23","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【C++】链表划分算法","slug":"链表划分","date":"2020-08-07T10:20:37.000Z","updated":"2020-08-07T10:20:37.000Z","comments":true,"path":"2020/08/07/链表划分/","link":"","permalink":"https://jinondo.github.io/2020/08/07/%E9%93%BE%E8%A1%A8%E5%88%92%E5%88%86/","excerpt":"","text":"链表根据数值划分给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。你应当保留两个分区中每个节点的初始相对位置。 弄两个新的表头，一个储存小于特定值的节点，一个储存大于特定值的结点，再结合，简单的直接上代码： 结点数据结构： 123456 // Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; 解决： 1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* partition(ListNode* head, int x) &#123; ListNode less_head(0); ListNode more_head(0); ListNode* less_ptr = &amp;less_head; ListNode* more_ptr = &amp;more_head; while (head) &#123; if (head-&gt;val &lt; x) &#123; less_ptr-&gt;next = head; less_ptr = head; &#125; else &#123; more_ptr-&gt;next = head; more_ptr = head; &#125; head = head-&gt;next; &#125; less_ptr-&gt;next = more_head.next; more_ptr-&gt;next = NULL; return less_head.next; &#125; &#125;; ps: 小象学院教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2 的笔记LeetCode题号： 86","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【C++】链表求环问题","slug":"链表求环问题","date":"2020-08-04T10:57:44.000Z","updated":"2020-08-04T10:57:44.000Z","comments":true,"path":"2020/08/04/链表求环问题/","link":"","permalink":"https://jinondo.github.io/2020/08/04/%E9%93%BE%E8%A1%A8%E6%B1%82%E7%8E%AF%E9%97%AE%E9%A2%98/","excerpt":"","text":"方法一：使用用C++的set库遍历链表逐一装入set集合，当出现一个结点已经收录在set中时，便找到了该节点 12345678910111213141516171819202122232425262728293031323334353637383940414243// 算法写在一个类里class Solution &#123;public: ListNode* detectCycle(ListNode* head) &#123; set&lt;ListNode*&gt; node_set; while (head) &#123; if (node_set.find(head) != node_set.end()) return head; node_set.insert(head); head = head-&gt;next; &#125; return NULL; &#125; &#125;;// 以下为测试int main() &#123; // c1结点为两链表相交的结点 ListNode a(1); ListNode b(2); ListNode c(3); ListNode d(4); ListNode e(5); ListNode f(6); ListNode g(7); a.next = &amp;b; b.next = &amp;c; c.next = &amp;d; d.next = &amp;e; e.next = &amp;f; f.next = &amp;g; g.next = &amp;c; Solution solve; ListNode* p = solve.detectCycle(&amp;a); if (p) cout &lt;&lt; &quot;链表有环，环的第一个结点为：&quot; &lt;&lt; p-&gt;val &lt;&lt; endl; else cout &lt;&lt; &quot;链表无环&quot; &lt;&lt; endl; return 0;&#125; 结果： 1链表有环，环的第一个结点为：3 方法二：快慢指针初始化两个指针指向头结点，第一个指针速度是1，第二个指针速度是2，即第一个指针每次遍历一个结点，第二个指针每次遍历两个结点，当他们相遇时，便说明了该链表存在环（女少口阿）而这种办法初步看只能求出是否有环，但求不出具体环的初始位置结点，故需要进一步分析：————图片来自小象学院教程课件重点是这句话：从head和meet（即相遇的点）出发，相遇即为环的起点（女少口阿*2）代码： 1234567891011121314151617181920212223242526272829303132// 算法写在一个类里class Solution &#123;public: ListNode* detectCycle(ListNode* head) &#123; ListNode* fast = head; // 快指针 ListNode* slow = head; // 慢指针 ListNode* meet = NULL; // 相遇结点 while (fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next; if (!fast) return NULL; fast = fast-&gt;next; if (fast == slow) &#123; meet = fast; break; &#125; &#125; if (meet == NULL) return NULL; while (head&amp;&amp;meet) &#123; if (head == meet) return head; head = head-&gt;next; meet = meet-&gt;next; &#125; return NULL; &#125; &#125;; 就执行用时和内存消耗来看，用set都是比较不友好的，用普通算法就贼省时省内存 |*￣ー￣| ps: 小象学院教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2 的笔记LeetCode题号： 142","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"【C++】两个链表求交点的算法问题","slug":"两个链表求交点","date":"2020-08-04T10:54:54.000Z","updated":"2020-08-04T10:54:54.000Z","comments":true,"path":"2020/08/04/两个链表求交点/","link":"","permalink":"https://jinondo.github.io/2020/08/04/%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%B1%82%E4%BA%A4%E7%82%B9/","excerpt":"","text":"方法一，使用C++的set库 set的使用方法：123456789101112131415161718int main() &#123; set&lt;int&gt; setA; const int lenA = 7; const int lenB = 8; int a[lenA] = &#123; 5,1,4,8,10,1,3 &#125;; int b[lenB] = &#123; 2,7,6,3,1,6,0,1 &#125;; for (int i = 0; i &lt; lenA; i++) &#123; setA.insert(a[i]); &#125; for (int i = 0; i &lt; lenB; i++) &#123; if (setA.find(b[i])!=setA.end()) printf(&quot;b[%d] = %d in array A.\\n&quot;, i, b[i]); &#125; return 0;&#125; 结果：123b[3] = 3 in array A.b[4] = 1 in array A.b[7] = 1 in array A. 解题：1234567891011121314151617181920// 算法写在一个类里class Solution &#123;public: ListNode* reverseBetween(ListNode* headA, ListNode* headB) &#123; set&lt;ListNode*&gt; node_set; while (headA) &#123; node_set.insert(headA); headA = headA-&gt;next; &#125; while (headB) &#123; if (node_set.find(headB) != node_set.end()) return headB; headB = headB-&gt;next; &#125; return NULL; &#125; &#125;; 方法2 对齐链表找相交点：先对齐两条链表，使其同时出发能同时到达交点，（即让长的那条链表的出发点后移到与短的链表头出发点对齐），空间复杂度O（1） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 遍历链表获得链表长度int get_list_len(ListNode* head) &#123; int len = 0; while (head) &#123; len++; head = head-&gt;next; &#125; return len;&#125;// 使长链表定位到对齐位置ListNode* forward_long_list(int longL, int shortL, ListNode* head) &#123; int delta = longL - shortL; while (head &amp;&amp; delta) &#123; head = head-&gt;next; delta--; &#125; return head;&#125;// 算法写在一个类里class Solution &#123;public: ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) &#123; int lenA = get_list_len(headA); int lenB = get_list_len(headB); if (lenA&gt;lenB) &#123; headA = forward_long_list(lenA, lenB, headA); &#125; else &#123; headB = forward_long_list(lenB, lenA, headB); &#125; while (headA&amp;&amp;headB) &#123; if (headA == headB) &#123; return headA; &#125; headA = headA-&gt;next; headB = headB-&gt;next; &#125; return NULL; &#125; &#125;;// 以下为测试int main() &#123; // c1结点为两链表相交的结点 ListNode a1(1); ListNode a2(2); ListNode b1(3); ListNode b2(4); ListNode b3(5); ListNode c1(6); ListNode c2(7); ListNode c3(8); a1.next = &amp;a2; a2.next = &amp;c1; c1.next = &amp;c2; c2.next = &amp;c3; b1.next = &amp;b2; b2.next = &amp;b3; b3.next = &amp;c1; Solution solve; ListNode* result = solve.getIntersectionNode(&amp;a1, &amp;b1); cout &lt;&lt; &quot;交点为：&quot; &lt;&lt; result-&gt;val; return 0;&#125; 结果： 1交点为：6 ps: 小象学院教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2 的笔记LeetCode题号： 160","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"链表逆置","slug":"链表逆置","date":"2020-08-03T08:49:08.000Z","updated":"2020-08-03T08:49:08.000Z","comments":true,"path":"2020/08/03/链表逆置/","link":"","permalink":"https://jinondo.github.io/2020/08/03/%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE/","excerpt":"","text":"链表逆置算法 C++实现链表结构： 123456789#include &lt;iostream&gt;using namespace std; // Definition for singly-linked list.struct ListNode &#123; int val; ListNode *next; ListNode(int x) : val(x), next(NULL) &#123;&#125;&#125;; 整个链表逆置：用一个新的空头指针，从第一个节点开始逐一接入新的头指针，新接入的节点的next为上一个接入节点的地址，以实现原地逆序代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344// 核心算法写在一个类里class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* new_head = NULL; ListNode* next = NULL; while (head) &#123; next = head-&gt;next; head-&gt;next = new_head; new_head = head; head = next; &#125; return new_head; &#125;&#125;;// 测试int main() &#123; ListNode a(1); ListNode b(2); ListNode c(3); ListNode d(4); ListNode e(5); a.next = &amp;b; b.next = &amp;c; c.next = &amp;d; d.next = &amp;e; Solution solve; ListNode* head = &amp;a, * p = head; cout &lt;&lt; &quot;矩阵逆置前：&quot; &lt;&lt; endl; while (p) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; endl; p = p-&gt;next; &#125; head = solve.reverseList(head); p = head; cout &lt;&lt; &quot;矩阵逆置后：&quot; &lt;&lt; endl; while (p) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; endl; p = p-&gt;next; &#125; return 0;&#125; 结果：123456789101112矩阵逆置前：12345矩阵逆置后：54321 将链表从m至n逆序 找到逆置的链表段的第一个节点及其前驱节点，再按上面的链表逆置方法逆置链表段，再进行整体连接代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 核心算法写在一个类里class Solution &#123;public: ListNode* reverseBetween(ListNode* head, int m, int n) &#123; int change_len = n - m + 1; // 需要逆置的节点个数 ListNode* pre_head = NULL; ListNode* result = head; while (head &amp;&amp; --m) &#123; pre_head = head; // 需要逆置的链表段的前驱节点 head = head-&gt;next; &#125; ListNode* modify_list_tail = head; // 当前的head，即逆置后的那一段链表的尾部 ListNode* new_head = NULL; ListNode* next = NULL; while (head &amp;&amp; change_len) &#123; next = head-&gt;next; head-&gt;next = new_head; new_head = head; head = next; change_len--; &#125; modify_list_tail-&gt;next = head; if (pre_head) &#123; pre_head-&gt;next = new_head; &#125; else &#123; result = new_head; &#125; return result; &#125;&#125;;// 以下为测试int main() &#123; ListNode a(1); ListNode b(2); ListNode c(3); ListNode d(4); ListNode e(5); a.next = &amp;b; b.next = &amp;c; c.next = &amp;d; d.next = &amp;e; Solution solve; ListNode* head = &amp;a, * p = head; cout &lt;&lt; &quot;矩阵逆置前：&quot; &lt;&lt; endl; while (p) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; endl; p = p-&gt;next; &#125; head = solve.reverseBetween(head, 2, 4); p = head; cout &lt;&lt; &quot;矩阵逆置后：&quot; &lt;&lt; endl; while (p) &#123; cout &lt;&lt; p-&gt;val &lt;&lt; endl; p = p-&gt;next; &#125; return 0;&#125; 结果： 123456789101112矩阵逆置前：12345矩阵逆置后：14325 ps: 教程 https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2 的笔记LeetCode题号： 206，92","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"MATLAB基础笔记7","slug":"MATLAB基础笔记7","date":"2020-08-01T15:48:40.000Z","updated":"2020-08-01T15:48:40.000Z","comments":true,"path":"2020/08/01/MATLAB基础笔记7/","link":"","permalink":"https://jinondo.github.io/2020/08/01/MATLAB%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B07/","excerpt":"","text":"MATLAB笔记7 统计和数据分析 / 曲线拟合和插值统计操作Mean算术平均, Median中位数, Mode中位数, and Quartile四分位数 12345678910111213141516171819202122232425&gt;&gt; load stockreturns;x4 = stocks(:,4);&gt;&gt; mean(x4)ans = -5.8728e-04&gt;&gt; median(x4)ans = 0.0617&gt;&gt; mode(x4)ans = -5.8764&gt;&gt; quantile(x4,0.25,1)ans = -1.5082 画图 12345x = 1:14;freqy = [1 0 1 0 4 0 1 0 3 1 0 0 1 1];subplot(1,3,1); bar(x,freqy); xlim([0 15]);subplot(1,3,2); area(x,freqy); xlim([0 15]);subplot(1,3,3); stem(x,freqy); xlim([0 15]); 箱线图 1234567&gt;&gt; marks = [80 81 81 84 88 92 92 94 96 97];boxplot(marks)prctile(marks, [25 50 75])ans = 81 90 94 boxplot 画箱线图， prctile获得分位数 Skewness偏态 skewness()12345678&gt;&gt; X = randn([10 3])*3;X(X(:,1)&lt;0, 1) = 0; X(X(:,3)&gt;0, 3) = 0;boxplot(X, &#123;&#x27;Right-skewed&#x27;, &#x27;Symmetric&#x27;, &#x27;Left-skewed&#x27;&#125;);y = skewness(X)y = 0.8167 -0.6878 -1.5176 统计假设检验 ttest2() 双样本 t 检验 h = ttest2(x,y) 使用双样本 t 检验返回原假设的检验决策，该原假设假定向量 x 和 y 中的数据来自均值相等、方差相同但未知的正态分布的独立随机样本。备择假设是 x 和 y 中的数据来自均值不相等的总体。如果检验在 5% 的显著性水平上拒绝原假设，则结果 h 为 1，否则为 0。 以下例子测试两个样本均值是否相等 12345678910111213&gt;&gt; load stockreturns;x1 = stocks(:,3); x2 = stocks(:,10);boxplot([x1, x2], &#123;&#x27;3&#x27;, &#x27;10&#x27;&#125;);[h,p] = ttest2(x1, x2)h = 1p = 0.0423 h=1，故拒绝原假设：x1和x2样本的均值相等；显著水平为5%，而p=0.0423&lt;0.05 曲线拟合 polyfit() 123&gt;&gt; x =[-1.2 -0.5 0.3 0.9 1.8 2.6 3.0 3.5];y =[-15.6 -8.5 2.2 4.5 6.6 8.2 8.9 10.0];fit = polyfit(x,y,1); 要进行拟合的散点为（-1.2，-15.6），（-0.5，-8.5）……polyfit第三参数为1表示用一次函数拟合函数返回ax+b中的a，b值 123&gt;&gt; xfit = [x(1):0.1:x(end)]; yfit = fit(1)*xfit + fit(2);plot(x,y,&#x27;ro&#x27;,xfit,yfit,&#x27;b&#x27;); set(gca,&#x27;FontSize&#x27;,14);legend(&#x27;data points&#x27;,&#x27;best-fit&#x27;,&#x27;location&#x27;,&#x27;northwest&#x27;); yfit = fit(1)*xfit + fit(2) 表示用一次拟合函数 y=ax+b 拟合 corrcoef() 求相关系数 相关系数 −1 ≤ 𝑟 ≤ 1，越接近于 1 则接近正相关，越接近 -1 则接近负相关 依然是上面的数据，判断 xy 的相关性 123456789&gt;&gt; x =[-1.2 -0.5 0.3 0.9 1.8 2.6 3.0 3.5];y =[-15.6 -8.5 2.2 4.5 6.6 8.2 8.9 10.0];scatter(x,y); box on; axis square;corrcoef(x,y)ans = 1.0000 0.9202 0.9202 1.0000 相关系数为0.9202接近 1，为正相关scatter() 功能为画散点图，也称气泡图（点是一个一个圈圈 ooooooo） 高阶多项式拟合 123456789&gt;&gt; x =[-1.2 -0.5 0.3 0.9 1.8 2.6 3.0 3.5];y =[-15.6 -8.5 2.2 4.5 6.6 8.2 8.9 10.0];figure(&#x27;Position&#x27;, [50 50 1500 400]);for i=1:3 subplot(1,3,i); p = polyfit(x,y,i); xfit = x(1):0.1:x(end); yfit = polyval(p,xfit); plot(x,y,&#x27;ro&#x27;,xfit,yfit,&#x27;b&#x27;); set(gca,&#x27;FontSize&#x27;,14); ylim([-17, 11]); legend(&#x27;Data points&#x27;,&#x27;Fitted curve&#x27;,&#x27;location&#x27;,&#x27;southeast&#x27;);end 越高阶不一定拟合的越好，可能会过拟合 regress() 多变量的函数拟合 拟合函数形如：𝑦 = 𝛽0 + 𝛽1𝑥1 + 𝛽2𝑥2 1234567891011121314load carsmall;y = MPG;x1 = Weight; x2 = Horsepower;X = [ones(length(x1),1) x1 x2];b = regress(y,X);x1fit = min(x1):100:max(x1);x2fit = min(x2):10:max(x2);[X1FIT,X2FIT]=meshgrid(x1fit,x2fit);YFIT=b(1)+b(2)*X1FIT+b(3)*X2FIT;scatter3(x1,x2,y,&#x27;filled&#x27;); hold on;mesh(X1FIT,X2FIT,YFIT); hold off;xlabel(&#x27;Weight&#x27;);ylabel(&#x27;Horsepower&#x27;);zlabel(&#x27;MPG&#x27;); view(50,10); 另一用法：[b,bint,r,rint,stats]=regress(y,X); 如果方程非线性用 Curve Fitting Toolbox: cftool() 即 曲线拟合工具箱:cftool()；matlab输入 cftool 或 cftool() Interpolation 插值 interp1() 线性插值 123456789101112131415161718x = linspace(0, 2*pi, 40); x_m = x;x_m([11:13, 28:30]) = NaN; y_m = sin(x_m);hold on;plot(x_m, y_m,&#x27;ro&#x27;, &#x27;MarkerFaceColor&#x27;, &#x27;r&#x27;);xlim([0, 2*pi]); ylim([-1.2, 1.2]); box on; %显示坐标区轮廓set(gca, &#x27;FontName&#x27;, &#x27;yahei&#x27;, &#x27;FontSize&#x27;, 16);set(gca, &#x27;XTick&#x27;, 0:pi/2:2*pi);set(gca, &#x27;XTickLabel&#x27;, &#123;&#x27;0&#x27;, &#x27;p/2&#x27;, &#x27;p&#x27;, &#x27;3p/2&#x27;, &#x27;2p&#x27;&#125;);m_i = ~isnan(x_m);y_i = interp1(x_m(m_i), ...y_m(m_i), x);plot(x,y_i,&#x27;-b&#x27;, ...&#x27;LineWidth&#x27;, 2);hold off; spline() 样条插值 12345678m_i = ~isnan(x_m);y_i = spline(x_m(m_i), y_m(m_i), x);hold on; plot(x_m, y_m,&#x27;ro&#x27;, &#x27;MarkerFaceColor&#x27;, &#x27;r&#x27;);plot(x,y_i,&#x27;-g&#x27;, &#x27;LineWidth&#x27;, 2); hold off;h = legend(&#x27;Original&#x27;, &#x27;Spline&#x27;);set(h,&#x27;FontName&#x27;, &#x27;kaiti&#x27;); 三次样条插值和 Hermite 多项式 12345678910111213x = -3:3; y = [-1 -1 -1 0 1 1 1]; t = -3:.01:3;s = spline(x,y,t); p = pchip(x,y,t);hold on; plot(t,s,&#x27;:g&#x27;, &#x27;LineWidth&#x27;, 2);plot(t,p,&#x27;--b&#x27;, &#x27;LineWidth&#x27;, 2);plot(x,y,&#x27;ro&#x27;, &#x27;MarkerFaceColor&#x27;, &#x27;r&#x27;);hold off; box on; set(gca, &#x27;FontSize&#x27;, 16);h = legend(2,&#x27;Original&#x27;, &#x27;Spline&#x27;, &#x27;Hermite&#x27;); interp2() meshgrid 格式的二维网格数据的插值 123456xx = -2:.5:2; yy = -2:.5:3;[X,Y] = meshgrid(xx,yy);Z = X.*exp(-X.^2-Y.^2);surf(X,Y,Z); hold on;plot3(X,Y,Z+0.01,&#x27;ok&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;r&#x27;) 123456xx_i = -2:.1:2; yy_i = -2:.1:3;[X_i,Y_i] = meshgrid(xx_i,yy_i);Z_i = interp2(xx,yy,Z,X_i,Y_i);surf(X_i,Y_i,Z_i); hold on;plot3(X,Y,Z+0.01,&#x27;ok&#x27;,&#x27;MarkerFaceColor&#x27;,&#x27;r&#x27;) 样条二维插值 123456789101112xx = -2:.5:2; yy = -2:.5:3; [X,Y] = meshgrid(xx,yy);Z = X.*exp(-X.^2-Y.^2); xx_i = -2:.1:2; yy_i = -2:.1:3;[X_i,Y_i] = meshgrid(xx_i,yy_i);Z_c = interp2(xx,yy,Z,X_i,Y_i,&#x27;cubic&#x27;);surf(X_i,Y_i,Z_c); hold on;plot3(X,Y,Z+0.01,&#x27;ok&#x27;, &#x27;MarkerFaceColor&#x27;,&#x27;r&#x27;);hold off; B站教程链接 https://www.bilibili.com/video/BV1GJ41137UH 台大郭彦甫matlab教程: 点击链接","categories":[],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://jinondo.github.io/tags/MATLAB/"}]},{"title":"MATLAB基础笔记6","slug":"MATLAB基础笔记6","date":"2020-07-31T09:27:09.000Z","updated":"2020-07-31T09:27:09.000Z","comments":true,"path":"2020/07/31/MATLAB基础笔记6/","link":"","permalink":"https://jinondo.github.io/2020/07/31/MATLAB%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B06/","excerpt":"","text":"MATLAB笔记6 线性方程式和线性系统线性方程 rref() 高斯消去法 𝑥 + 2𝑦 + 𝑧 = 22𝑥 + 6𝑦 + 𝑧 = 7𝑥 + 𝑦 + 4𝑧 = 3⇒系数矩阵的增广矩阵1 2 1 22 6 1 71 1 4 3 123456789A = [1 2 1;2 6 1;1 1 4];b = [2; 7; 3];R = rref([A b])R = 1 0 0 -3 0 1 0 2 0 0 1 1 R为高斯消去法后的矩阵 LU分解法/三角分解法 12345678910111213141516171819202122232425&gt;&gt; A = [1 1 1;2 3 5;4 6 8];[L, U, P] = lu(A);&gt;&gt; LL = 1.0000 0 0 0.2500 1.0000 0 0.5000 0 1.0000&gt;&gt; UU = 4.0000 6.0000 8.0000 0 -0.5000 -1.0000 0 0 1.0000&gt;&gt; PP = 0 0 1 1 0 0 0 1 0 \\ or mldivide() 矩阵左除法 解方程组：𝑥 + 2𝑦 + 𝑧 = 22𝑥 + 6𝑦 + 𝑧 = 7𝑥 + 𝑦 + 4𝑧 = 3 123456789&gt;&gt; A = [1 2 1;2 6 1;1 1 4];b = [2; 7; 3];x = A\\bx = -3.0000 2.0000 1.0000 用逆矩阵求解 解方程组：𝑥 + 2𝑦 + 𝑧 = 22𝑥 + 6𝑦 + 𝑧 = 7𝑥 + 𝑦 + 4𝑧 = 3求解 A𝒙=b ——&gt; 𝒙 = 𝑨^−1𝒃 123A = [1 2 1;2 6 1;1 1 4];b = [2; 7; 3];x = inv(A)*b 逆矩阵前提是A可逆，A^-1 = 1/det(A) * adj(A)判断可用 det(), 为0则不可逆 123456789101112131415161718&gt;&gt; A = [ 1 2 3 4; 2 4 6 8; ...9 8 7 6; 1 3 2 8];inv(A)det(A)警告: 矩阵为奇异工作精度。 ans = Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Inf Infans = 0 cond(A) 检查矩阵的好坏情况 A=1 2 32 4.0001 69 8 7𝑩 =1 2 32 5 69 8 7 条件数更小的矩阵做逆矩阵运算更精确，反之条件书远大于1则对逆运算十分敏感 1234567891011&gt;&gt; A = [ 1 2 3; 2 4.0001 6; 9 8 7]; cond(A)B = [ 1 2 3; 2 5 6; 9 8 7]; cond(B)ans = 4.3483e+05ans = 45.5623 可以看出A矩阵的cond返回值更大，故A不适合做逆运算 线性系统 eig() 求特征值和特征向量 𝑨 =2 −121 −5 123456789101112&gt;&gt; [v,d]=eig([2 -12;1 -5])v = 0.9701 0.9487 0.2425 0.3162d = -1.0000 0 0 -2.0000 v为特征向量，d为特征值 B站教程链接 https://www.bilibili.com/video/BV1GJ41137UH 台大郭彦甫matlab教程: 点击链接","categories":[],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://jinondo.github.io/tags/MATLAB/"}]},{"title":"MATLAB基础笔记5","slug":"MATLAB基础笔记5","date":"2020-07-30T13:52:00.000Z","updated":"2020-07-30T13:52:00.000Z","comments":true,"path":"2020/07/30/MATLAB基础笔记5/","link":"","permalink":"https://jinondo.github.io/2020/07/30/MATLAB%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B05/","excerpt":"","text":"MATLAB笔记5 方程求根符号求根 符号声明 123456789101112&gt;&gt; syms xx + x + x(x + x + x)/4 ans = 3*x ans = (3*x)/4 或者 123x=sym(&#x27;x&#x27;);x + x + x(x + x + x)/4 可以看出syms更为简洁 solve() 求方程根 求该方程的根：𝑦 = 𝑥 ∙ sin(𝑥) − 𝑥 = 0 123456789syms xsolve(&#x27;x*sin(x)-x&#x27;, x)% MATLAB新版本不能加单引号：solve(x*sin(x)-x, x)ans = 0 pi/2 12345678&gt;&gt; syms xy = x*sin(x)-x;solve(y, x) ans = 0 pi/2 解方程组:𝑥 − 2𝑦 = 5𝑥 + 𝑦 = 6 1234567891011121314151617181920212223syms x yeq1 = x - 2*y - 5;eq2 = x + y - 6;A = solve(eq1,eq2,x,y)A = 包含以下字段的 struct: x: [1×1 sym] y: [1×1 sym]&gt;&gt; A.x %通过该结构体获得x,y ans = 17/3 &gt;&gt; A.y ans = 1/3 用solve()解带参数的方程 解 𝑎𝑥2 − 𝑏 = 0 其中a，b为未知参数 1234567syms x a bsolve(a*x^2-b)ans = b^(1/2)/a^(1/2) -b^(1/2)/a^(1/2) 这里 x为首选要求的变量值 指定要解的变量： 1234567&gt;&gt; syms x a bsolve(a*x^2-b,x) ans = b^(1/2)/a^(1/2) -b^(1/2)/a^(1/2) 123456&gt;&gt; syms x a bsolve(a*x^2-b,b) ans = a*x^2 用 diff() 和符号求导数求导：𝑦 = 4𝑥^5 1234567syms xy = 4*x^5;yprime = diff(y)yprime = 20*x^4 用 int() 和符号求积分求 ∫𝑥^2 𝑒^𝑥 𝑑𝑥 ————– 条件𝑧(0) = 0 1234syms x; y = x^2*exp(x);z = int(y); z = z-subs(z, x, 0) subs(z, x, 0) 是把z中的x替换为0，即将x=0带入z求解积分结果的常数，满足条件𝑧(0) = 0 fsolve()求根 𝑓(𝑥)= 1.2𝑥 + 0.3 + 𝑥 ∙ sin(𝑥) 123456f2 = @(x) (1.2*x+0.3+x*sin(x));fsolve(f2,0)ans = -0.3500 第二个参数0设定初值x0，一般设定在解附近，若不知道解，也可随意设置，这个例子设为0，1，2都可以，3以上的整数会找不到解 fzero() 该函数使用条件是函数有穿过x轴！ 以下要求的函数没有达到该条件，故解为NaN 1234567891011121314151617&gt;&gt; f=@(x)x.^2fzero(f,0.1)f = 包含以下值的 function_handle: @(x)x.^2正在退出 fzero: 将终止搜索包含符号变化的区间 因为在搜索期间遇到 NaN 或 Inf 函数值。(-1.37296e+154 处的函数值为 Inf。)请检查函数或使用其他起始值重试。ans = NaN 使用fsolve： 12345678910111213&gt;&gt; fsolve(f,0)Equation solved at initial point.fsolve completed because the vector of function values at the initial pointis near zero as measured by the value of the function tolerance, andthe problem appears regular as measured by the gradient.&lt;stopping criteria details&gt;ans = 0 增加option参数 1234f=@(x)x.^2options=optimset(&#x27;MaxIter&#x27;,1e3,&#x27;TolFun&#x27;,1e-10);fsolve(f,0.1,options)fzero(f,0.1,options) MaxIter设置最大迭代数 Number of iterationsTolFun 设置函数容差 Tolerance roots() 用于多项式求根求根： 𝑓(𝑥) = 𝑥^5 − 3.5𝑥^4 + 2.75𝑥^3 + 2.125𝑥^2 − 3.875𝑥 + 1.25 123456789&gt;&gt; roots([1 -3.5 2.75 2.125 -3.875 1.25])ans = 2.0000 + 0.0000i -1.0000 + 0.0000i 1.0000 + 0.5000i 1.0000 - 0.5000i 0.5000 + 0.0000i 可见解都有虚数部分 递归函数 Recursive Functions12345678function output = fact(n)% 递归计算n的阶乘if n==1output = 1;elseoutput = n * fact(n-1);endend B站教程链接 https://www.bilibili.com/video/BV1GJ41137UH 台大郭彦甫matlab教程: 点击链接","categories":[],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://jinondo.github.io/tags/MATLAB/"}]},{"title":"MATLAB基础笔记4","slug":"MATLAB基础笔记4","date":"2020-07-30T08:00:57.000Z","updated":"2020-07-30T08:00:57.000Z","comments":true,"path":"2020/07/30/MATLAB基础笔记4/","link":"","permalink":"https://jinondo.github.io/2020/07/30/MATLAB%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B04/","excerpt":"","text":"MATLAB笔记4 导数/积分/微分操作多项式导数积分多项式用row vector表示f(x) = x^3 - 2x -5 表示为：p = [1 0 -2 -5]; polyval() 求多项式值 12345a = [9,-5,3,7]; x = -2:0.01:5;f = polyval(a,x);plot(x,f,&#x27;LineWidth&#x27;, 2);xlabel(&#x27;x&#x27;); ylabel(&#x27;f(x)&#x27;);set(gca, &#x27;FontSize&#x27;, 14) polyder() 求导 12p=[5 0 -2 0 1];polyder(p) 例子Plot the polynomial𝑓(𝑥) = (5𝑥3 − 7𝑥2 + 5𝑥 + 10)(4𝑥2 + 12𝑥 − 3)and its derivative for −2 ≤ 𝑥 ≤ 1 123456789a = [5,-7,5,10];b = [4,12,-3];c = conv(a,b); % 卷积操作/多项式相乘x = -2:0.01:1;f = polyval(c,x);f1 = polyval(polyder(c),x);plot(x,f,&#x27;b--&#x27;,x,f1,&#x27;r-&#x27;,&#x27;LineWidth&#x27;, 2);xlabel(&#x27;x&#x27;); ylabel(&#x27;f(x)&#x27;);legend(&#x27;f(x)&#x27;,&#x27;f&#x27;&#x27;(x)&#x27;) polyint() 多项式积分𝑓(𝑥) = 5𝑥^4 − 2𝑥^2 + 1 12p=[5 0 -2 0 1];polyint(p, 3) % 第二个参数是积分后多出的常数 1polyval(polyint(p, 3),7) 数值微分和数值积分 diff()123456x = [1 2 5 2 1];diff(x)ans = 1 3 -3 -1 计算(1,5) 和 (2,7)连线斜率 123456&gt;&gt; x = [1 2]; y = [5 7];slope = diff(y)./diff(x)slope = 2 利用 diff() 计算微分Given 𝑓(𝑥) = sin(𝑥), find 𝑓′(𝑥0) at 𝑥0 = 𝜋/2 using ℎ = 0.1 1234x0 = pi/2; h = 0.1;x = [x0 x0+h];y = [sin(x0) sin(x0+h)];m = diff(y)./diff(x) 利用 diff() 计算导函数 1234h = 0.5; x = 0:h:2*pi;y = sin(x); m = diff(y)./diff(x); 二次导数 12345678x = -2:0.005:2; y = x.^3;m = diff(y)./diff(x);m2 = diff(m)./diff(x(1:end-1)); %二次导plot(x,y,x(1:end-1),m,x(1:end-2),m2);xlabel(&#x27;x&#x27;, &#x27;FontSize&#x27;, 18);ylabel(&#x27;y&#x27;, &#x27;FontSize&#x27;, 18);legend(&#x27;f(x) =x^3&#x27;,&#x27;f&#x27;&#x27;(x)&#x27;,&#x27;f&#x27;&#x27;&#x27;&#x27;(x)&#x27;,&#x27;Location&#x27;,&#x27;SouthEast&#x27;);set(gca, &#x27;FontSize&#x27;, 18); Function Handle 把一个function作为参数传入另一个function时，需要使用function handle，即使用@符号 12345678function [y] = xy_plot(input,x)% xy_plot receives the handle of a function% and plots that function of x% input指代那个传入的函数y = input(x); plot(x,y,&#x27;r--&#x27;);xlabel(&#x27;x&#x27;); ylabel(&#x27;function(x)&#x27;);end 上面为函数xy_plot，使用如下： 123xy_plot(@sin,0:0.01:2*pi);xy_plot(@cos,0:0.01:2*pi);xy_plot(@exp,0:0.01:2*pi); integral() 计算 ∫𝑥^3−2𝑥−5 𝑑𝑥 范围0~2的积分12y = @(x) 1./(x.^3-2*x-5);integral(y,0,2) 二重积分和三重积分 B站教程链接 台大郭彦甫matlab教程: 点击链接","categories":[],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://jinondo.github.io/tags/MATLAB/"}]},{"title":"MATLAB基础笔记3","slug":"MATLAB基础笔记3","date":"2020-07-19T07:28:13.000Z","updated":"2020-07-19T07:28:13.000Z","comments":true,"path":"2020/07/19/MATLAB基础笔记3/","link":"","permalink":"https://jinondo.github.io/2020/07/19/MATLAB%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B03/","excerpt":"","text":"MATLAB笔记3：数据类型和文件读写此篇笔记只记录较重要知识点，一些和其他编程语言相似不做记录 数据类型 String连接 1234567891011&gt;&gt; s1 = &#x27;Example&#x27;;s2 = &#x27;String&#x27;;&gt;&gt; s3 = [s1 s2]s3 = &#x27;ExampleString&#x27;&gt;&gt; s4 = [s1;s2]错误使用 vertcat要串联的数组的维度不一致。 以上s4会出错，因为两个字符串要纵向连接需要维度相同，即字符个数相同 String筛选 1234567891011121314&gt;&gt; str = &#x27;aardvark&#x27;;&#x27;a&#x27; == strans = 1×8 logical 数组 1 1 0 0 0 1 0 0&gt;&gt; str(str==&#x27;a&#x27;) = &#x27;z&#x27;str = &#x27;zzrdvzrk&#x27; 结构体 12345678910111213141516&gt;&gt; student.name = &#x27;John Doe&#x27;; student.id = &#x27;jdo2@sfu.ca&#x27;; student.number = 301073268; student.grade = [100, 75, 73; ... 95, 91, 85.5; ... 100, 98, 72];studentstudent = 包含以下字段的 struct: name: &#x27;John Doe&#x27; id: &#x27;jdo2@sfu.ca&#x27; number: 301073268 grade: [3×3 double] 增加结构体数组的元素 : 1234student(2).name = &#x27;Ann Lane&#x27;;student(2).id = &#x27;aln4@sfu.ca&#x27;;student(2).number = 301078853;student(2).grade = [95 100 90; 95 82 97; 100 85 100]; 获得Ann的grade的第三个数据 12345&gt;&gt; student(2).grade(3)ans = 100 结构体 function 1234567891011121314151617181920&gt;&gt; fieldnames(student)ans = 4×1 cell 数组 &#123;&#x27;name&#x27; &#125; &#123;&#x27;id&#x27; &#125; &#123;&#x27;number&#x27;&#125; &#123;&#x27;grade&#x27; &#125;&gt;&gt; rmfield(student,&#x27;id&#x27;)ans = 包含以下字段的 1×2 struct 数组: name number grade 嵌套结构体 12345678910111213141516171819202122232425&gt;&gt; A = struct(&#x27;data&#x27;, [3 4 7; 8 0 1], &#x27;nest&#x27;, ...struct(&#x27;testnum&#x27;, &#x27;Test 1&#x27;, ...&#x27;xdata&#x27;, [4 2 8],&#x27;ydata&#x27;, [7 1 6]));A(2).data = [9 3 2; 7 6 5];A(2).nest.testnum = &#x27;Test 2&#x27;;A(2).nest.xdata = [3 4 2];A(2).nest.ydata = [5 0 9];A.nestans = 包含以下字段的 struct: testnum: &#x27;Test 1&#x27; xdata: [4 2 8] ydata: [7 1 6]ans = 包含以下字段的 struct: testnum: &#x27;Test 2&#x27; xdata: [3 4 2] ydata: [5 0 9] 以上结构体A有两个域，data和nest，nest结构体又含有三个域 Cell Array : cell数组12345A(1,1)=&#123;[1 4 3; 0 5 8; 7 2 9]&#125;;A(1,2)=&#123;&#x27;Anne Smith&#x27;&#125;;A(2,1)=&#123;3+7i&#125;;A(2,2)=&#123;-pi:pi:pi&#125;;A 另一种方式：12345A&#123;1,1&#125;=[1 4 3; 0 5 8; 7 2 9];A&#123;1,2&#125;=&#x27;Anne Smith&#x27;;A&#123;2,1&#125;=3+7i;A&#123;2,2&#125;=-pi:pi:pi;A 大括号”{}”索引和括号“()”索引的区别:123456789101112131415161718192021222324&gt;&gt; AA = 2×2 cell 数组 &#123;3×3 double &#125; &#123;&#x27;Anne Smith&#x27;&#125; &#123;[3.0000 + 7.0000i]&#125; &#123;1×3 double &#125;&gt;&gt; A(1,1)ans = 1×1 cell 数组 &#123;3×3 double&#125;&gt;&gt; A&#123;1,1&#125;ans = 1 4 3 0 5 8 7 2 9 可以看出大括号索引能获得具体数据信息 幻方矩阵123456789101112131415161718192021&gt;&gt; a = magic(3)a = 8 1 6 3 5 7 4 9 2&gt;&gt; sum(a)ans = 15 15 15&gt;&gt; sum(a,2)ans = 15 15 15 每行总和等于每列总和 关于cell array 的 function123456789101112131415161718192021222324252627&gt;&gt; aa = 8 1 6 3 5 7 4 9 2&gt;&gt; b = num2cell(a)b = 3×3 cell 数组 &#123;[8]&#125; &#123;[1]&#125; &#123;[6]&#125; &#123;[3]&#125; &#123;[5]&#125; &#123;[7]&#125; &#123;[4]&#125; &#123;[9]&#125; &#123;[2]&#125;&gt;&gt; c = mat2cell(a, [1 1 1], 3)c = 3×1 cell 数组 &#123;1×3 double&#125; &#123;1×3 double&#125; &#123;1×3 double&#125; mat2cell()函数有两种划分方法： C = mat2cell(A,dim1Dist,…,dimNDist)C = mat2cell(A,rowDist)第一种示例： 123456789101112131415161718&gt;&gt; A = reshape(1:20,5,4)&#x27;A = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 &gt;&gt; C = mat2cell(A,[1 3],[2 3])C = 2×2 cell 数组 &#123;1×2 double&#125; &#123;1×3 double&#125; &#123;3×2 double&#125; &#123;3×3 double&#125; [1,3] 和 [2,3] 分别对应4X5的矩阵A 多维数组 123456789101112% &#123;&#125;中第三个为第三维的索引% -------第一层-------A&#123;1,1,1&#125; = [1 2;4 5];A&#123;1,2,1&#125; = &#x27;Name&#x27;;A&#123;2,1,1&#125; = 2-4i;A&#123;2,1,1&#125; = 7;% -------第二层-------A&#123;1,1,2&#125; = &#x27;Name2&#x27;;A&#123;1,2,2&#125; = 3;A&#123;2,1,2&#125; = 0:1:3;A&#123;2,2,2&#125; = [4 5]&#x27;; 数组连接（二维与三维）：cat() 方法 12345A=[1 2;3 4]; B=[5 6;7 8];C=cat(1,A,B); % 纵向连接C=cat(2,A,B); % 横向连接C=cat(3,A,B); % 三维连接 cell array 的三维连接 123456789A&#123;1,1&#125; = [1 2;4 5];A&#123;1,2&#125; = &#x27;Name&#x27;;A&#123;2,1&#125; = 2-4i;A&#123;2,2&#125; = 7;B&#123;1,1&#125; = &#x27;Name2&#x27;;B&#123;1,2&#125; = 3;B&#123;2,1&#125; = 0:1:3;B&#123;2,2&#125; = [4 5]&#x27;;C = cat(3, A, B) File Access 文件存取 保存 1234clear; a = magic(4);save mydata1.matsave mydata2.mat -ascii 读取 12load(&#x27;mydata1.mat&#x27;)load(&#x27;mydata2.mat&#x27;,&#x27;-ascii&#x27;) 加载excel文件 123Score = xlsread(&#x27;04Score.xlsx&#x27;)Score = xlsread(&#x27;04Score.xlsx&#x27;, &#x27;B2:D4&#x27;)% B2：B4 指定行列数 写入excel文件 1234% 求出每个人的平均成绩写回 excel文件M = mean(Score&#x27;)&#x27;;xlswrite(&#x27;04Score.xlsx&#x27;, M, 1, &#x27;E2:E4&#x27;);xlswrite(&#x27;04Score.xlsx&#x27;, &#123;&#x27;Mean&#x27;&#125;, 1, &#x27;E1&#x27;); 底层文件操作 fopen，fclose，fscanf，fprintf 12345678x = 0:pi/10:pi; y = sin(x); fid = fopen(&#x27;sinx.txt&#x27;,&#x27;w&#x27;);for i=1:11 fprintf(fid,&#x27;%5.3f %8.4f\\n&#x27;, x(i), y(i));endfclose(fid); type sinx.txt type filename：显示文件内容文件中内容如下：（列标题除外！） x y 0.000 0.0000 0.314 0.3090 0.628 0.5878 0.942 0.8090 1.257 0.9511 1.571 1.0000 1.885 0.9511 2.199 0.8090 2.513 0.5878 2.827 0.3090 3.142 0.0000 1234567891011fid = fopen(&#x27;04asciiData.txt&#x27;,&#x27;r&#x27;); i = 1;while ~feof(fid) name(i,:) = fscanf(fid,&#x27;%5c&#x27;,1); year(i) = fscanf(fid,&#x27;%d&#x27;,1); no1(i) = fscanf(fid,&#x27;%d&#x27;,1); no2(i) = fscanf(fid,&#x27;%d&#x27;,1); no3(i) = fscanf(fid,&#x27;%g&#x27;,1); no4(i) = fscanf(fid,&#x27;%g\\n&#x27;); i=i+1;endfclose(fid); feof(fid)检测文件是否结束 B站教程链接 台大郭彦甫matlab教程: 点击链接","categories":[],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://jinondo.github.io/tags/MATLAB/"}]},{"title":"MATLAB基础笔记2","slug":"MATLAB基础笔记2","date":"2020-07-18T09:34:55.000Z","updated":"2020-07-18T09:34:55.000Z","comments":true,"path":"2020/07/18/MATLAB基础笔记2/","link":"","permalink":"https://jinondo.github.io/2020/07/18/MATLAB%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B02/","excerpt":"","text":"MATLAB笔记2：程序结构和方法Structured Programming &amp; Function 程序结构 循环结构实例 12345for i=1:10 x=linspace(0,10,101); plot(x,sin(x+i)); print(gcf,&#x27;-deps&#x27;,strcat(&#x27;plot&#x27;,num2str(i),&#x27;.ps&#x27;));end 逻辑运算符 if-else 1234567if condition1 statement1elseif condition2 statement2else statement3end 12345if rem(a, 2) == 0 disp(&#x27;a is even&#x27;)else disp(&#x27;a is odd&#x27;)end rem()函数计算余数 switch 12345678910switch input_numcase -1 disp(&#x27;negative 1&#x27;);case 0 disp(&#x27;zero&#x27;);case 1 disp(&#x27;positive 1&#x27;);otherwise disp(&#x27;other value&#x27;);end while循环 1234n = 1;while prod(1:n) &lt; 1e100 n = n + 1;end prod(a)函数计算向量a元素的积，在这里计算n的阶乘 for循环 123for variable=start : increment : end commandsend 1234for n=1:10 a(n)=2^n;enddisp(a) 关于预分配内存加快程序速度 tic 和 toc 可以计算时间间隔，结果是B所花时间更少 在我的机器上结果反而是相反的！这点不太清楚 break 12345678910x = 2; k = 0; error = inf;error_threshold = 1e-32;while error &gt; error_threshold if k &gt; 100 break end x = x - sin(x)/cos(x); error = abs(x - pi); k = k + 1;end Fuction 12345678910function y = mean(x)% MEAN Average or mean value.% S = MEAN(X) is the mean value of the elements in X% if X is a vector. For matrices, S is a row% vector containing the mean value of each column.if nargin==2 &amp;&amp; ischar(dim)flag = dim;elseif nargin &lt; 3flag = &#x27;default&#x27;;end 1234function [x,y] = getxandy(a,b)% 获得ab，可以返回两个值x = a+b;y = a-b; 结果：12345678910&gt;&gt; [a,b] = getxandy(2,3)a = 5b = -1 function中的默认参数12345function [volume]=pillar(Do,Di,height)if nargin==2, height=1;endvolume=abs(Do.^2-Di.^2).*height*pi/4; 判断nargin，即input的参数个数如果为2，设置height值默认为1 12function test(varargin)disp(varargin&#123;1:numel(varargin)&#125;) 结果12&gt;&gt; test([2 3 4]) 2 3 4 function handle123f = @(x) exp(-2*x);x = 0:0.1:2;plot(x, f(x)); x为 function handle 传入的参数，对x进行exp()运算（求e的-2x次幂），返回结果 B站教程链接 台大郭彦甫matlab教程: 点击链接","categories":[],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://jinondo.github.io/tags/MATLAB/"}]},{"title":"MATLAB基础笔记1","slug":"MATLAB基础笔记1","date":"2020-07-18T05:08:22.000Z","updated":"2020-07-18T05:08:22.000Z","comments":true,"path":"2020/07/18/MATLAB基础笔记1/","link":"","permalink":"https://jinondo.github.io/2020/07/18/MATLAB%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B01/","excerpt":"","text":"MATLAB笔记1: Array Operation变量 ans 变量1sin(cos(pi)) 等于12cos(pi)sin(ans) 其他变量 i,j: complex number Inf: ∞ eps: 2.2204e-016 NaN: not a number pi: π 123x = 1/0 # 结果为 Infx = log(0) # 结果为 -Infx = inf/inf # 结果为 NaN 数组 Array (Vector and Matrix) 向量和矩阵 Row Vector 行向量: 1a = [1 2 3 4] Column Vector 列向量: 1a = [1; 2; 3; 4] 数组操作 Array Indexing 索引1234567&gt;&gt; A = [1 21 6;5 17 9; 31 2 7]A = 1 21 6 5 17 9 31 2 7 索引：123456789101112131415161718&gt;&gt; A(8) # 列优先ans = 9&gt;&gt; A([1 3 5])ans = 1 31 17&gt;&gt; A([1 3;1 3])ans = 1 31 1 31 123456789101112&gt;&gt; A(3,2)ans = 2&gt;&gt; A([1 3],[1 3]) # 第1,3行和第1,3列交叉的部分ans = 1 6 31 7 Colon Operator 冒号操作12345678910111213141516171819202122232425&gt;&gt; B = 1:5B = 1 2 3 4 5&gt;&gt; B = 1:2:5B = 1 3 5&gt;&gt; B = [1:5;2:3:15;-2:0.5:0]B = 1.0000 2.0000 3.0000 4.0000 5.0000 2.0000 5.0000 8.0000 11.0000 14.0000 -2.0000 -1.5000 -1.0000 -0.5000 0&gt;&gt; str = &#x27;a&#x27;:2:&#x27;z&#x27;str = &#x27;acegikmoqsuwy&#x27; Indexing Using Colon Operator1234567891011121314151617181920&gt;&gt; A = [1 0 0; 5 0 0; 31 0 7]A = 1 0 0 5 0 0 31 0 7&gt;&gt; A(3,:)ans = 31 0 7&gt;&gt; A(3,:) = []A = 1 0 0 5 0 0 Array Manipulation 数组操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&gt;&gt; x1 = A+ax1 = 3 4 5 6 7 6 11 10 9&gt;&gt; x2 = A/ax2 = 0.5000 1.0000 1.5000 2.0000 2.5000 2.0000 4.5000 4.0000 3.5000&gt;&gt; x3 = A./a # 和上面结果一致x3 = 0.5000 1.0000 1.5000 2.0000 2.5000 2.0000 4.5000 4.0000 3.5000&gt;&gt; x4 = A^a # 即 A*Ax4 = 36 36 32 60 65 60 104 114 108&gt;&gt; x5 = A.^ax5 = 1 4 9 16 25 16 81 64 49&gt;&gt; C = A&#x27;C = 1 4 9 2 5 8 3 4 7 右边那五个操作为矩阵操作，点乘为每个对应元素去做操作，除法为A/B = A*inv(B),即B的逆矩阵，详细参考矩阵操作 Array Concatenation 矩阵连接123456789101112131415161718&gt;&gt; D = [A B]D = 1 2 3 3 3 3 4 5 4 2 4 9 9 8 7 1 3 1&gt;&gt; E = [A;B]E = 1 2 3 4 5 4 9 8 7 3 3 3 2 4 9 1 3 1 特殊矩阵 linspace(a,b,c) eye(n): nxn identity matrix：单位矩阵 zeros(n1,n2): n1xn2 zero matrix：零矩阵 ones(n1,n2): n1xn2 matrix with every entry as 1 diag(): diagonal matrix 对角矩阵12345678910111213&gt;&gt; c = diag([2 3 4])c = 2 0 0 0 3 0 0 0 4&gt;&gt; d = linspace(0,13,6)d = 0 2.6000 5.2000 7.8000 10.4000 13.0000 矩阵 function方法大多是对列column去做操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&gt;&gt; A = [1 2 3;0 5 6;7 0 9]A = 1 2 3 0 5 6 7 0 9&gt;&gt; max(A) # 对每一列去求max，以下同理ans = 7 5 9&gt;&gt; max(max(A)) # 求一个矩阵最大值的方法ans = 9&gt;&gt; min(A)ans = 0 0 3&gt;&gt; sum(A)ans = 8 7 18&gt;&gt; mean(A)ans = 2.6667 2.3333 6.0000&gt;&gt; sort(A)ans = 0 0 3 1 2 6 7 5 9&gt;&gt; sortrows(A)ans = 0 5 6 1 2 3 7 0 9&gt;&gt; size(A)ans = 3 3&gt;&gt; length(A)ans = 3&gt;&gt; find(A==0)ans = 2 6&gt;&gt; find(A==2)ans = 4 sort 和 sortrows区别是，sort对每一列进行排序，sortrows对第一列排序且 整行调换顺序 B站教程链接 台大郭彦甫matlab教程: 点击链接","categories":[],"tags":[{"name":"MATLAB","slug":"MATLAB","permalink":"https://jinondo.github.io/tags/MATLAB/"}]},{"title":"使用Hexo发布博客","slug":"使用Hexo发布博客","date":"2020-07-17T10:26:00.000Z","updated":"2020-07-17T10:26:00.000Z","comments":true,"path":"2020/07/17/使用Hexo发布博客/","link":"","permalink":"https://jinondo.github.io/2020/07/17/%E4%BD%BF%E7%94%A8Hexo%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"使用HEXO发布博客的小知识点方便自己发布博客，记录一下大概流程 编辑博客 发布新的博客 1hexo new post 你的新博客名称 之后会在source/_posts下生成一个md文件，则为你的博客文件 编辑博客文件: xxx.md 用hexo s进行本地预览 发布草稿 1hexo new draft 你的新博客名称 之后会在source/_drafts下生成一个md文件，则为你的博客文件 在本地预览 1hexo s --draft 草稿发布为正式博客 1hexo publish 你的新博客名称 发布博客 修改博客内容后（包括修改yml或md文件）1234hexo cleanhexo ghexo clean # 需要再次clean才能有效develophexo d 或者可以先在本地预览再hexo d12hexo shexo server # 二选一 npm 路径： C:\\Users\\用户\\AppData\\Roaming\\npm\\","categories":[],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://jinondo.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]},{"title":"My First Artical","slug":"My-First-Artical","date":"2020-07-10T09:05:18.000Z","updated":"2020-07-10T09:05:18.000Z","comments":true,"path":"2020/07/10/My-First-Artical/","link":"","permalink":"https://jinondo.github.io/2020/07/10/My-First-Artical/","excerpt":"","text":"JINONDO ‘S FIRST ARTICLEummm write somethingDESCRIBEthis is my first article CODEjava c++ python CONCLUSIONNOTHING","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-07-01T15:00:58.000Z","updated":"2020-07-01T15:00:58.000Z","comments":true,"path":"2020/07/01/hello-world/","link":"","permalink":"https://jinondo.github.io/2020/07/01/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://jinondo.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"https://jinondo.github.io/categories/Java/"},{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://jinondo.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://jinondo.github.io/tags/Java/"},{"name":"并发编程","slug":"并发编程","permalink":"https://jinondo.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"Springboot","slug":"Springboot","permalink":"https://jinondo.github.io/tags/Springboot/"},{"name":"iconfont","slug":"iconfont","permalink":"https://jinondo.github.io/tags/iconfont/"},{"name":"算法","slug":"算法","permalink":"https://jinondo.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"MATLAB","slug":"MATLAB","permalink":"https://jinondo.github.io/tags/MATLAB/"},{"name":"Hexo博客","slug":"Hexo博客","permalink":"https://jinondo.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2/"}]}