<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>贪心法算法例子【总】 | Jinondo's Blog</title><meta name="description" content="本文章记录贪心法的一些 LeetCode 题目，是我学习b站小象学院视频教程所做笔记，文末注明教程出处。侵删 ¯\_( ͡° ͜ʖ ͡°)_&#x2F;¯ LeetCode [455] 分发饼干问题描述假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj"><meta name="keywords" content="算法"><meta name="author" content="Jinondo"><meta name="copyright" content="Jinondo"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/cytlogo.png"><link rel="canonical" href="https://jinondo.github.io/2020/09/17/%E8%B4%AA%E5%BF%83%E6%B3%95%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%90/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="贪心法算法例子【总】"><meta property="og:url" content="https://jinondo.github.io/2020/09/17/%E8%B4%AA%E5%BF%83%E6%B3%95%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%90/"><meta property="og:site_name" content="Jinondo's Blog"><meta property="og:description" content="本文章记录贪心法的一些 LeetCode 题目，是我学习b站小象学院视频教程所做笔记，文末注明教程出处。侵删 ¯\_( ͡° ͜ʖ ͡°)_&#x2F;¯ LeetCode [455] 分发饼干问题描述假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj"><meta property="og:image" content="https://jinondo.github.io/img/default4.jpg"><meta property="article:published_time" content="2020-09-17T12:35:53.000Z"><meta property="article:modified_time" content="2020-09-19T15:46:16.767Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="递归-回溯-分治算法例子【总】" href="https://jinondo.github.io/2020/09/26/%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF-%E5%88%86%E6%B2%BB/"><link rel="next" title="最大最小堆相关算法" href="https://jinondo.github.io/2020/08/10/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: {"text":"WDNMD,THE,END,OF,THE,FXXKING,WORLD","fontSize":"15px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/cytAvatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">3</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-455-分发饼干"><span class="toc-number">1.</span> <span class="toc-text">LeetCode [455] 分发饼干</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#问题描述"><span class="toc-number">1.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例"><span class="toc-number">1.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解决思路"><span class="toc-number">1.3.</span> <span class="toc-text">解决思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法代码"><span class="toc-number">1.4.</span> <span class="toc-text">算法代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-376-摆动序列"><span class="toc-number">2.</span> <span class="toc-text">LeetCode [376] 摆动序列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述"><span class="toc-number">2.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例-1"><span class="toc-number">2.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解题思路"><span class="toc-number">2.3.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法代码-1"><span class="toc-number">2.4.</span> <span class="toc-text">算法代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-402-移掉-k-位数字"><span class="toc-number">3.</span> <span class="toc-text">LeetCode [402] 移掉 k 位数字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-1"><span class="toc-number">3.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例-2"><span class="toc-number">3.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#解题思路-1"><span class="toc-number">3.3.</span> <span class="toc-text">解题思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法代码-2"><span class="toc-number">3.4.</span> <span class="toc-text">算法代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-55-跳跃游戏"><span class="toc-number">4.</span> <span class="toc-text">LeetCode [55] 跳跃游戏</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-2"><span class="toc-number">4.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例-3"><span class="toc-number">4.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法思路"><span class="toc-number">4.3.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法代码-3"><span class="toc-number">4.4.</span> <span class="toc-text">算法代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-55-跳跃游戏2"><span class="toc-number">5.</span> <span class="toc-text">LeetCode [55] 跳跃游戏2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-3"><span class="toc-number">5.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例-4"><span class="toc-number">5.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法思路-1"><span class="toc-number">5.3.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法代码-4"><span class="toc-number">5.4.</span> <span class="toc-text">算法代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#LeetCode-452-用最少数量的箭引爆气球"><span class="toc-number">6.</span> <span class="toc-text">LeetCode [452] 用最少数量的箭引爆气球</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-4"><span class="toc-number">6.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例-5"><span class="toc-number">6.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法思路-2"><span class="toc-number">6.3.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法代码-5"><span class="toc-number">6.4.</span> <span class="toc-text">算法代码</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#poj-2431-最优加油方法"><span class="toc-number">7.</span> <span class="toc-text">poj [2431] 最优加油方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#题目描述-5"><span class="toc-number">7.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#示例-6"><span class="toc-number">7.2.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法代码-6"><span class="toc-number">7.3.</span> <span class="toc-text">算法代码</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><header class="post-bg" id="page-header" style="background-image: url(/img/default4.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Jinondo's Blog</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">贪心法算法例子【总】</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-09-17 20:35:53"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-09-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-09-19 23:46:16"><i class="fas fa-history fa-fw"></i> 更新于 2020-09-19</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p><font color="red"><strong>本文章记录贪心法的一些 LeetCode 题目，是我学习b站小象学院视频教程所做笔记，文末注明教程出处。侵删 ¯\_( ͡° ͜ʖ ͡°)_/¯</strong></font></p>
<h1 id="LeetCode-455-分发饼干"><a href="#LeetCode-455-分发饼干" class="headerlink" title="LeetCode [455] 分发饼干"></a>LeetCode [455] 分发饼干</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj &gt;= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>输入: [1,2,3], [1,1]  </p>
<p>输出: 1</p>
<p>解释:<br>你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。<br>虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。<br>所以你应该输出1。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>先把输入的两组数据排序，然后根据每一个饼干从小到大去选择对应可以被满足的孩子</p>
<h2 id="算法代码"><a href="#算法代码" class="headerlink" title="算法代码"></a>算法代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; g, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(g.begin(),g.end());</span><br><span class="line">        <span class="built_in">std</span>:sort(s.begin(),s.end());</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cookie = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(child&lt;g.size() &amp;&amp; cookie&lt;s.size())&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[child]&lt;=s[cookie])&#123;</span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            cookie++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="LeetCode-376-摆动序列"><a href="#LeetCode-376-摆动序列" class="headerlink" title="LeetCode [376] 摆动序列"></a>LeetCode [376] 摆动序列</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<h2 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h2><p>示例 1:<br>输入: [1,7,4,9,2,5]<br>输出: 6<br>解释: 整个序列均为摆动序列。  </p>
<p>示例 2:<br>输入: [1,17,5,10,13,15,10,5,16,8]<br>输出: 7<br>解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>使用一个状态机，有三种状态  </p>
<ol>
<li><strong>开始状态 BEGIN</strong>：如果下一个数字比当前的数字要大，则转入上升状态UP；如果下一个数字比当前的数字要小，则转入下降状态DOWN；</li>
<li><strong>上升状态 UP</strong>：如果下一个数字比当前数字更大，则无事发生；如果下一个数字比当前数字小（即符合摆动序列），令max_length++，即长度加一，然后转入下降状态。</li>
<li><strong>下降状态 DOWN</strong>：如果下一个数字比当前数字更小，则无数发生；如果下一个数字比当前数字大，符合摆动序列，则令max_length++，长度加一，然后转入上升状态。</li>
</ol>
<ul>
<li>在状态机运行过程中吗，如果有持续上升，或持续下降的情况，则取上升到最大或下降到最小的那个数值，保证后面的数字可以满足摆动序列的概率最大，即涉及到贪心的思想。  </li>
<li>套用一个循环遍历，算出最长子序列的长度。</li>
</ul>
<h2 id="算法代码-1"><a href="#算法代码-1" class="headerlink" title="算法代码"></a>算法代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums.size(); <span class="comment">// 序列个数小于2则本身就是摇摆序列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置状态机的三种状态</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BEGIN= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> UP = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> DOWN = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> STATE = BEGIN;</span><br><span class="line">        <span class="keyword">int</span> max_length = <span class="number">1</span>; <span class="comment">// 先设置最大长度至少为1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第二个元素开始遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span>(STATE)&#123;</span><br><span class="line">            <span class="keyword">case</span> BEGIN: <span class="comment">// 开始状态</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&lt;nums[i])&#123;</span><br><span class="line">                    STATE = UP;</span><br><span class="line">                    max_length++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&gt;nums[i])&#123;</span><br><span class="line">                    STATE = DOWN;</span><br><span class="line">                    max_length++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> UP:  <span class="comment">// 数值上升状态</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&gt;nums[i])&#123;</span><br><span class="line">                    STATE=DOWN;</span><br><span class="line">                    max_length++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DOWN: <span class="comment">// 数值下降状态</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i<span class="number">-1</span>]&lt;nums[i])&#123;</span><br><span class="line">                    STATE = UP;</span><br><span class="line">                    max_length++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="LeetCode-402-移掉-k-位数字"><a href="#LeetCode-402-移掉-k-位数字" class="headerlink" title="LeetCode [402] 移掉 k 位数字"></a>LeetCode [402] 移掉 k 位数字</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个以字符串表示的非负整数 num，移除这个数中的 k 位数字，使得剩下的数字最小。</p>
<p>注意:</p>
<ul>
<li>num 的长度小于 10002 且 ≥ k。</li>
<li>num 不会包含任何前导零。</li>
</ul>
<h2 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h2><p>示例 1 :</p>
<p>输入: num = “1432219”, k = 3<br>输出: “1219”<br>解释: 移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219。</p>
<p>示例 2 :</p>
<p>输入: num = “10200”, k = 1<br>输出: “200”<br>解释: 移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>题目要求剩下的数字组成的数值最大，故每次要留下较小的数字，从最高位开始，尽量取小的数。<br>即设计一个栈，从第一个元素按顺序加入栈，每次一个数字加入栈要判断该数字大小，如果比栈顶数字大，则直接压入栈，如果比栈顶数字小，则把栈顶出栈，继续判断该值和更新后的栈顶大小。循环直到所有数字都进入栈或者k&lt;=0，如果数字全进入栈了但k依然大于0，则继续将栈做弹出操作直到k=0。</p>
<h2 id="算法代码-2"><a href="#算法代码-2" class="headerlink" title="算法代码"></a>算法代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">removeKdigits</span><span class="params">(<span class="built_in">string</span> num, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; S;  <span class="comment">// 用vector作为类似栈结构来使用</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> result = <span class="string">""</span>;  <span class="comment">// 储存最终结果</span></span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;num.length(); i++)&#123;</span><br><span class="line">            number = num[i] - <span class="string">'0'</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当栈非空 且 栈顶（这里就是vector最后一个元素，即最后一个数字）大于number 且 k&gt;0（即仍然可以删除数字）</span></span><br><span class="line">            <span class="keyword">while</span>(S.size()!=<span class="number">0</span> &amp;&amp; S[S.size()<span class="number">-1</span>]&gt;number &amp;&amp; k&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                S.pop_back();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(number!=<span class="number">0</span> || S.size()!=<span class="number">0</span>)&#123;</span><br><span class="line">                S.push_back(number);  <span class="comment">// 将数字压入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(S.size()!=<span class="number">0</span> &amp;&amp; k&gt;<span class="number">0</span>)&#123; <span class="comment">// 此时栈不空且还能继续删数字，故继续删至k为0</span></span><br><span class="line">            S.pop_back();</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;S.size();i++)&#123;  <span class="comment">// 储存结果到 result 中</span></span><br><span class="line">            result.append(<span class="number">1</span>,<span class="string">'0'</span>+S[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result == <span class="string">""</span>)&#123;</span><br><span class="line">            result = <span class="string">"0"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="LeetCode-55-跳跃游戏"><a href="#LeetCode-55-跳跃游戏" class="headerlink" title="LeetCode [55] 跳跃游戏"></a>LeetCode [55] 跳跃游戏</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>定一个非负整数数组，你最初位于数组的第一个位置。</p>
<p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p>
<p>判断你是否能够到达最后一个位置。</p>
<h2 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h2><p>示例 1:</p>
<p>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。  </p>
<p>示例 2:</p>
<p>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</p>
<h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>先去找出每一个位置作为当前位置时可以跳的最远的位置，程序中即 <code>index[i] = nums[i]+i</code>，使用贪心法思想，则是依次找每一个位置能跳的最远距离 max_index，一次循环更新一次当前能跳的最远距离，直到jump值（遍历到的那个位置）大于max_index, 或者jump已经到达末尾。检查jump如果等于到了末尾则表示可以从位置0到达最后一个位置。</p>
<h2 id="算法代码-3"><a href="#算法代码-3" class="headerlink" title="算法代码"></a>算法代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canJump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; index; <span class="comment">// 计算最远可跳至的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            index.push_back(i+nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> jump = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_index = index[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(jump&lt;index.size() &amp;&amp; jump&lt;=max_index)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max_index&lt;index[jump])&#123;</span><br><span class="line">                max_index = index[jump]; <span class="comment">// 保存可以跳的更远的目标位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            jump++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(jump == index.size())&#123; <span class="comment">// 若jump到达数组尾部，说明可以到达最后一个位置，返回真</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 否则返回假</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="LeetCode-55-跳跃游戏2"><a href="#LeetCode-55-跳跃游戏2" class="headerlink" title="LeetCode [55] 跳跃游戏2"></a>LeetCode [55] 跳跃游戏2</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数数组，你最初位于数组的第一个位置。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>你的目标是使用最少的跳跃次数到达数组的最后一个位置。  </p>
<h2 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h2><p>示例:<br>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
<h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><p>贪心原理：<br>每次都跳到当前能跳到的最远位置，如果发现该位置不能跳到末尾，则再选择这之前的一个位置，该位置是除了当前位置能跳最远位置的位置。<br>其实思路说起来有点绕，看代码吧。</p>
<h2 id="算法代码-4"><a href="#算法代码-4" class="headerlink" title="算法代码"></a>算法代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;<span class="number">2</span>)&#123; <span class="comment">// 如果数组小于2则直接返回0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> current_max_index = nums[<span class="number">0</span>]; <span class="comment">// 当前可到达的最远位置</span></span><br><span class="line">        <span class="keyword">int</span> pre_max_index = nums[<span class="number">0</span>]; <span class="comment">// 遍历各个位置过程中，可达到的最远位置</span></span><br><span class="line">        <span class="keyword">int</span> jump = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;current_max_index)&#123; <span class="comment">// 若无法再向前移动移动了，才进行跳跃</span></span><br><span class="line">                jump++; <span class="comment">// 更新跳跃次数</span></span><br><span class="line">                current_max_index = pre_max_index; <span class="comment">// 更新当前可到达的最远位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pre_max_index&lt;nums[i]+i)&#123;</span><br><span class="line">                pre_max_index = nums[i] +i; <span class="comment">// 在遍历时如果找到一个能跳更远位置的位置，则更新 pre_max_index</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jump;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="LeetCode-452-用最少数量的箭引爆气球"><a href="#LeetCode-452-用最少数量的箭引爆气球" class="headerlink" title="LeetCode [452] 用最少数量的箭引爆气球"></a>LeetCode [452] 用最少数量的箭引爆气球</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。</p>
<p>一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。</p>
<h2 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h2><p>Example:</p>
<p>输入:<br>[[10,16], [2,8], [1,6], [7,12]]</p>
<p>输出:<br>2</p>
<p>解释:<br>对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。</p>
<h2 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h2><p>初始化一支箭，射爆尽量多的气球</p>
<h2 id="算法代码-5"><a href="#算法代码-5" class="headerlink" title="算法代码"></a>算法代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a,<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] &lt; b[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(points.begin(),points.end(),cmp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> shoot_num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> shoot_begin = points[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> shoot_end = points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;points.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[i][<span class="number">0</span>] &lt;= shoot_end)&#123;</span><br><span class="line">                shoot_begin = points[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span>(shoot_end &gt; points[i][<span class="number">1</span>])&#123;</span><br><span class="line">                    shoot_end = points[i][<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                shoot_num++;</span><br><span class="line">                shoot_begin = points[i][<span class="number">0</span>];</span><br><span class="line">                shoot_end = points[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shoot_num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="poj-2431-最优加油方法"><a href="#poj-2431-最优加油方法" class="headerlink" title="poj [2431] 最优加油方法"></a>poj [2431] 最优加油方法</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>A group of cows grabbed a truck and ventured on an expedition deep into the jungle. Being rather poor drivers, the cows unfortunately managed to run over a rock and puncture the truck’s fuel tank. The truck now leaks one unit of fuel every unit of distance it travels.</p>
<p>To repair the truck, the cows need to drive to the nearest town (no more than 1,000,000 units distant) down a long, winding road. On this road, between the town and the current location of the truck, there are N (1 &lt;= N &lt;= 10,000) fuel stops where the cows can stop to acquire additional fuel (1..100 units at each stop).</p>
<p>The jungle is a dangerous place for humans and is especially dangerous for cows. Therefore, the cows want to make the minimum possible number of stops for fuel on the way to the town. Fortunately, the capacity of the fuel tank on their truck is so large that there is effectively no limit to the amount of fuel it can hold. The truck is currently L units away from the town and has P units of fuel (1 &lt;= P &lt;= 1,000,000).</p>
<p>Determine the minimum number of stops needed to reach the town, or if the cows cannot reach the town at all.</p>
<p>中文翻译：<br>一群牛抢了一辆卡车，冒险进入丛林深处探险。由于牛是相当糟糕的司机，不幸的是它们撞到了一块石头，并刺穿了卡车的油箱。现在，卡车每行驶一单位距离就会泄漏一单位燃料。  </p>
<p>为了修理卡车，奶牛需要沿着一条长长的蜿蜒的公路，驱车到最近的城镇(距离不超过100万单位)。在这条道路上，在城镇和卡车的当前位置之间，有N (1 &lt;= N &lt;= 10,000)燃料站，奶牛可以在那里停下来获取额外的燃料(1..每站100个)。  </p>
<p>丛林对人类来说是个危险的地方，对牛来说尤其危险。因此，奶牛们希望在去镇上的路上尽可能少地停下来加油。幸运的是，他们卡车的油箱容量是如此之大，以至于实际上没有限制它所能容纳的燃料量。卡车目前距离城镇L单位，有P单位的燃料(1 &lt;= P &lt;= 1,000,000)。  </p>
<p>确定到达城镇所需的最低停车次数，或者如果奶牛根本无法到达城镇。  </p>
<h2 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h2><p>Sample Input</p>
<p>4<br>4 4<br>5 2<br>11 5<br>15 10<br>25 10  </p>
<p>Sample Output</p>
<p>2</p>
<h2 id="算法代码-6"><a href="#算法代码-6" class="headerlink" title="算法代码"></a>算法代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.first &gt; b.first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_minimum_stop</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> P, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; &amp;stop)</span> </span>&#123;</span><br><span class="line">	priority_queue&lt;<span class="keyword">int</span>&gt; Q; <span class="comment">// 存储有量的最大堆</span></span><br><span class="line">	<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> dis = <span class="number">0</span>;</span><br><span class="line">	stop.push_back(make_pair(<span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">	sort(stop.begin(), stop.end(), cmp);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stop.size(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dis = L - stop[i].first;</span><br><span class="line">		<span class="keyword">while</span> (!Q.empty() &amp;&amp; P&lt;dis)</span><br><span class="line">		&#123;</span><br><span class="line">			P += Q.top();</span><br><span class="line">			Q.pop();</span><br><span class="line">			result++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (Q.empty() &amp;&amp; P &lt; dis) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		P = P - dis;</span><br><span class="line">		L = stop[i].first;</span><br><span class="line">		Q.push(stop[i].second);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; stop;</span><br><span class="line">	<span class="keyword">int</span> N;</span><br><span class="line">	<span class="keyword">int</span> L;</span><br><span class="line">	<span class="keyword">int</span> P;</span><br><span class="line">	<span class="keyword">int</span> distance;</span><br><span class="line">	<span class="keyword">int</span> fuel;</span><br><span class="line">	scanf_s(<span class="string">"%d"</span>, &amp;N);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		scanf_s(<span class="string">"%d %d"</span>, &amp;distance, &amp;fuel);</span><br><span class="line">		stop.push_back(make_pair(distance, fuel));</span><br><span class="line">	&#125;</span><br><span class="line">	scanf_s(<span class="string">"%d %d"</span>, &amp;L, &amp;P);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, get_minimum_stop(L, P, stop));</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ps: 小象学院教程 <a href="https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1GW411Q77S?t=7029&amp;p=2</a> </p>
</blockquote>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Jinondo</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jinondo.github.io/2020/09/17/%E8%B4%AA%E5%BF%83%E6%B3%95%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%90/">https://jinondo.github.io/2020/09/17/%E8%B4%AA%E5%BF%83%E6%B3%95%E7%AE%97%E6%B3%95%E4%BE%8B%E5%AD%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jinondo.github.io" target="_blank">Jinondo's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post_share"><div class="social-share" data-image="/img/default4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/26/%E9%80%92%E5%BD%92-%E5%9B%9E%E6%BA%AF-%E5%88%86%E6%B2%BB/"><img class="prev-cover" data-src="/img/default4.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">递归-回溯-分治算法例子【总】</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/10/%E6%9C%80%E5%A4%A7%E6%9C%80%E5%B0%8F%E5%A0%86%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95/"><img class="next-cover" data-src="/img/default4.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">最大最小堆相关算法</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/10/04/二叉树与图/" title="二叉树与图"><img class="relatedPosts_cover" data-src="/img/default4.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-10-04</div><div class="relatedPosts_title">二叉树与图</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/04/两个链表求交点/" title="【C++】两个链表求交点的算法问题"><img class="relatedPosts_cover" data-src="/img/default4.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-04</div><div class="relatedPosts_title">【C++】两个链表求交点的算法问题</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/07/多个有序链表的合并/" title="多个有序链表的合并"><img class="relatedPosts_cover" data-src="/img/default4.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-07</div><div class="relatedPosts_title">多个有序链表的合并</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/09/基本加减计算器实现/" title="基本加减计算器实现"><img class="relatedPosts_cover" data-src="/img/default4.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-09</div><div class="relatedPosts_title">基本加减计算器实现</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/09/堆栈和队列简单算法题/" title="堆栈和队列简单算法题"><img class="relatedPosts_cover" data-src="/img/default4.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-09</div><div class="relatedPosts_title">堆栈和队列简单算法题</div></div></a></div><div class="relatedPosts_item"><a href="/2020/08/10/最大最小堆相关算法/" title="最大最小堆相关算法"><img class="relatedPosts_cover" data-src="/img/default4.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2020-08-10</div><div class="relatedPosts_title">最大最小堆相关算法</div></div></a></div></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Jinondo</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/third-party/ClickShowText.js"></script></body></html>